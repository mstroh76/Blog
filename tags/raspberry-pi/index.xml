<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Raspberry Pi on Blog</title>
    <link>https://mstroh76.github.io/Blog/tags/raspberry-pi/</link>
    <description>Recent content in Raspberry Pi on Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2021, Martin Strohmayer</copyright>
    <lastBuildDate>Wed, 30 Jun 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://mstroh76.github.io/Blog/tags/raspberry-pi/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Mit PiBAN Festplatten löschen?</title>
      <link>https://mstroh76.github.io/Blog/post/piban/</link>
      <pubDate>Wed, 30 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://mstroh76.github.io/Blog/post/piban/</guid>
      <description>
        
          &lt;p&gt;Hin und wieder möchte man Festplatten sicher löschen. Mit dem Projekt iBAN und einer Raspberry Pi könnte es gelingen - oder etwa nicht?&lt;/p&gt;
&lt;h2 id=&#34;beschreibung&#34;&gt;Beschreibung&lt;/h2&gt;
&lt;p&gt;Öftmals liegt eine alte SATA-Festplatte herum und man würde sie ja gerne verkaufen oder verschenken. Aber es bleibt immer die Unsicherheit wegen der alten Daten. Kann man die vielleicht rekonstruieren? Dann vernichtet man die Platte doch lieber. Vielleicht wendet man sich sogar an eine offizielles Vernichtungsfirma. Dort kann man die Platte ja sogar mehrmals schreddern und den Rest dann gleich mitnehmen - Sicher ist Sicher (aber bitte bezahlen nicht vergessen). Nachzulesen auf &lt;a href=&#34;https://de.wikipedia.org/wiki/Schredder-Aff%C3%A4re&#34;&gt;https://de.wikipedia.org/wiki/Schredder-Aff%C3%A4re&lt;/a&gt;  .&lt;br&gt;
Wie gesagt, wenn man nicht ganz so hohe Standards hat, könnte ein sicheres Löschen auch ausreichen und die Hardware könnte weiterverwendet werden. Wichtig zu sagen ist, dass sich das Verfahren nur auf HDD anwenden lässt, nicht auf die modernen SSD-Festplatten!&lt;/p&gt;
&lt;p&gt;PiBAN ist eine Projekt das eine paar Scripts enthält. Wenn man diese Scripts auf einem Raspberry Pi mit Raspberry Pi OS installiert, hat man eine automatische Löschstation.
Der Source liegt auf Github als Fork bei GC2 unter &lt;a href=&#34;https://github.com/GrazerComputerClub/PiBAN&#34;&gt;https://github.com/GrazerComputerClub/PiBAN&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;Ehrlich gesagt finde ich das Projekt zu gefährlich für eine dezidierte Station. Steckt man da mal eine falsche Festplatte an, weil man das Projekt vielleicht vergessen hat oder was auch immer, würde die Platte schon gelöscht werden.
Ich habe deshalb davon abgesehen das Projekt so um zu setzen.&lt;/p&gt;
&lt;p&gt;Die Installation kann man im Script &#39;install.sh&#39; sehen. Es werden die Tools mit &lt;code&gt;apt install secure-delete nwipe&lt;/code&gt; installiert. Das Script &#39;update.sh&#39; richtet die automatischen USB Funktionen ein, damit bei Anschluss alles sofort gestartet wird.&lt;br&gt;
Der eigentliche Schreddervorgang wird mit dem Script &#39;nuke.sh&#39; gestartet. Dort ist wiederum nur die Zeile &lt;code&gt;shred -v --iterations=1 &amp;quot;$1&amp;quot;&lt;/code&gt; die essentielle Funktion.
Rund herum gibt es auch alternative Programmaufrufe zum sicheren Löschen mit nwipe. Wie dem Kommentar aber zu entnehmen ist, sind die sehr bis &#39;unmöglich&#39; langsam.&lt;/p&gt;
&lt;p&gt;Das Programm &amp;quot;shred&amp;quot; scheint hier ein Kompromiss zwischen Sicherheit und Geschwindigkeit zu sein. Näheres zum Programm findet man auf &lt;a href=&#34;https://wiki.ubuntuusers.de/shred/&#34;&gt;https://wiki.ubuntuusers.de/shred/&lt;/a&gt; .&lt;/p&gt;
&lt;h2 id=&#34;eigene-löschstation-ohne-piban&#34;&gt;Eigene Löschstation ohne PiBAN&lt;/h2&gt;
&lt;p&gt;Urspünglich wollte ich eine alte Raspberry Pi 1 für so eine Löschstation vorbereiten und zur Sicherheit den Vorgang nur über eine Taste und Display (4 Stellen Siebensegment) starten.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;sudo apt -y install secure-delete wiringpi pv
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;/usr/local/bin/usbmount.sh:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 1&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#!/usr/bin/env bash
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt; 2&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Detected new device: &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$1&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; &amp;gt;&amp;gt;/var/log/PiBAN.log
&lt;span class=&#34;ln&#34;&gt; 3&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;devname&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;basename &lt;span class=&#34;nv&#34;&gt;$1&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 4&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;logname&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/tmp/&lt;span class=&#34;nv&#34;&gt;$devname&lt;/span&gt;.log
&lt;span class=&#34;ln&#34;&gt; 5&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;ACTION&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;add&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 6&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;then&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 7&lt;/span&gt;    &lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$1&lt;/span&gt; &amp;gt; /dev/shm/hdd
&lt;span class=&#34;ln&#34;&gt; 8&lt;/span&gt;    2display Hdd
&lt;span class=&#34;ln&#34;&gt; 9&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fi&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;10&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;11&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;ACTION&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;remove&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;12&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;then&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;13&lt;/span&gt;	/bin/rm /dev/shm/hdd
&lt;span class=&#34;ln&#34;&gt;14&lt;/span&gt;	2display noHd
&lt;span class=&#34;ln&#34;&gt;15&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fi&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;/usr/local/bin/shred.sh (gestartet aus rc.local oder systemd):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 1&lt;/span&gt;# 1: status led 
&lt;span class=&#34;ln&#34;&gt; 2&lt;/span&gt;# 2: shred HDD if connected
&lt;span class=&#34;ln&#34;&gt; 3&lt;/span&gt;gpio -g mode 2 in
&lt;span class=&#34;ln&#34;&gt; 4&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 5&lt;/span&gt;echo shredstation started ... 
&lt;span class=&#34;ln&#34;&gt; 6&lt;/span&gt;2display idle
&lt;span class=&#34;ln&#34;&gt; 7&lt;/span&gt;while true; do
&lt;span class=&#34;ln&#34;&gt; 8&lt;/span&gt;	GPIO=`gpio -g read 2`
&lt;span class=&#34;ln&#34;&gt; 9&lt;/span&gt;	if [ $GPIO = 0 ]; then
&lt;span class=&#34;ln&#34;&gt;10&lt;/span&gt;		HDD=`cat /dev/shm/hdd` 
&lt;span class=&#34;ln&#34;&gt;11&lt;/span&gt;		echo found $HDD
&lt;span class=&#34;ln&#34;&gt;12&lt;/span&gt;		if [ ! -z &amp;#34;$HDD&amp;#34; ] ; then
&lt;span class=&#34;ln&#34;&gt;13&lt;/span&gt;			2display shrd
&lt;span class=&#34;ln&#34;&gt;14&lt;/span&gt;			shred -v -z -n 1 $HDD &amp;gt; /var/log/shred.log 2&amp;gt;&amp;amp;1
&lt;span class=&#34;ln&#34;&gt;15&lt;/span&gt;			2display done
&lt;span class=&#34;ln&#34;&gt;16&lt;/span&gt;		fi
&lt;span class=&#34;ln&#34;&gt;17&lt;/span&gt;	fi
&lt;span class=&#34;ln&#34;&gt;18&lt;/span&gt;	sleep 1
&lt;span class=&#34;ln&#34;&gt;19&lt;/span&gt;done
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;/etc/udev/rules.d/usbmount.rules:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;ACTION==&amp;#34;add&amp;#34;, KERNEL==&amp;#34;sd*[!0-9]&amp;#34;, SUBSYSTEM==&amp;#34;block&amp;#34;, RUN+=&amp;#34;/usr/local/bin/usbmount.sh %N&amp;#34;
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;ACTION==&amp;#34;remove&amp;#34;, KERNEL==&amp;#34;sd*[!0-9]&amp;#34;, SUBSYSTEM==&amp;#34;block&amp;#34;, RUN+=&amp;#34;/usr/local/bin/usbmount.sh %N&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Scripts aktivieren:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;udevadm control --reload-rules &amp;amp;&amp;amp; udevadm trigger
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;sudo udevadm control --reload-rules
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Leider ist es mir nicht gelungen den Prozentforschritt am Display anzuzeigen. Das Tool pv war nicht in der Lage den Output von shred korrekt auszuwerten &lt;code&gt;sudo shred -n 1 -v /dev/sda | pv -n | 2display&lt;/code&gt; hat leider nicht funktioniert.&lt;/p&gt;
&lt;h2 id=&#34;schreddern-und-analyse&#34;&gt;Schreddern und Analyse&lt;/h2&gt;
&lt;p&gt;Prinzipiell eine gute Idee aber dann habe ich Performance Tests gemacht und analysiert wie lange so eine Löschung nun wirklich dauert. Denn eins habe ich nicht bedacht, die Löschung hängt von der USB Geschwindigkeit ab. Die ist bekanntlich bei allen Raspberry Pis bis 3+ auf USB 2.0 mit max. 30 MB/s begrenzt. Nimmt man nun den Raspberry Pi 4 mit der USB 3.0 Schnittstelle, so erreicht er bis zu 100 MB/s also ca. 3-4 mal mehr.&lt;br&gt;
Als Festplatte verwendete ich eine 3 TB SATA-Platte mit einer USB 3.0 Docking Station mit externer Stromversorgung.&lt;/p&gt;
&lt;p&gt;Schreddern, ein Durchgang:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;sudo shred -n 1 -z -v /dev/sda 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Nur mit Nullen beschreiben:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;shred -n 0 -z -v /dev/sda
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Schreddern und dann mit Nullen beschreiben:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;sudo shred -n 1 -z -v /dev/sda 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Das Schreddern dauerte mit dem Pi 1 (800 MHz) ca. 49 Stunden, also etwas mehr als 2 Tage. Mit dem Pi 4 dauerte es hingegen nur 11 Stunden, also rund einen halben Tag. Damit erreichte der Pi 1 ca. 17 MB/s und der Pi 4 ca. 78 MB/s.&lt;br&gt;
Das Nullsetzen der Platte dauerte mit dem Pi 1 ca. 44 Stunden und beim Pi 4 ca. 9 Stunden. Damit erreichte der Pi 1 ca. 19 MB/s und der Pi 4 ca. 95 MB/s.&lt;br&gt;
Zusammen würde als der Vorgang mit dem Pi 1 93 Stunden dauern, das sind dann fast 4 Tage!&lt;br&gt;
Beim Pi 4 wäre die 3 TB Festplatte nach 20 Stunden gelöscht.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Alles in allem macht eine Station für mich wenig Sinn, wenn nur einen &#39;edler&#39; Pi 4 diese Aufgabe in akzeptabler Zeit erledigen kann. Damit macht das ganze PiBAN Projekt wenig Sinn und reduziert sich auf das Linux-Tool &amp;quot;shred&amp;quot;.&lt;/strong&gt;&lt;br&gt;
Also stecke ich die Platte einfach an meinen Pi 4 an und starten die Löschung manuell. Für die wenige male die ich so eine Aufgabe benötige. Nachdem das alles schon so lange gedauert hat, habe ich mir den Test mit &amp;quot;nwipe&amp;quot; im übrigen erspart.&lt;/p&gt;
        
      </description>
    </item>
    
    <item>
      <title>Raspberry Pis verwalten mit Ansible</title>
      <link>https://mstroh76.github.io/Blog/post/ansible/</link>
      <pubDate>Wed, 02 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://mstroh76.github.io/Blog/post/ansible/</guid>
      <description>
        
          &lt;p&gt;Wer in seinem Netwerk mehrere Raspberry Pi laufen hat und diese gemeinsam verwalten will, kann mit Ansible diese Aufgabe erledigen ...&lt;/p&gt;
&lt;h2 id=&#34;beschreibung&#34;&gt;Beschreibung&lt;/h2&gt;
&lt;p&gt;Inzwischen haben immer mehr Leute mehrere Raspberry Pis in ihrem Netzwerk laufen. Eine für die Homeautomation, eine als NAS-Server und vielleicht noch eine mit Kameraaufgaben wie Überwachung oder für die Vögelbeobachtung. Hin und wieder möchte man die Rapsberry Pis dann aber auch aktualisieren oder andere Aktien auf allen durchführen. Einzel kann das dann zur mühevollen Aufgabe werden. Ansible kann hier allerdings einiges vereinfachen und einzelne Befehle oder Befehlsequenzen auf allen System ausführen.&lt;/p&gt;
&lt;h2 id=&#34;vorbereitung-ssh-zugriff-ohne-passwort&#34;&gt;Vorbereitung: SSH Zugriff ohne Passwort&lt;/h2&gt;
&lt;p&gt;Damit man von einem zentralen PC oder Laptop ohne Passworteingabe auf den Raspberry Pi zugreifen kann muss SSH korrekt eingerichtet sein. Der SSH-Key vom Host muss auf allen Clients (Raspberry Pis) übertragen werden. Dazu muss am Host der SSH-Key einmalig erstellt werden. Das macht man mit dem Befehl ssh-keygen. Man kann hier dann eine Passwort vergeben oder auch leer lassen - wie man möchte. Danach kann der SSH-Key auf die Clients übertragen wwerden. Das macht man am besten mit &lt;code&gt;ssh-copy-id&lt;/code&gt; gefolgt vom username pi und hostname des Clients.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;ls ~/.ssh/id_*.pub || ssh-keygen
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;ssh-copy-id pi@homeautomation
&lt;span class=&#34;ln&#34;&gt;3&lt;/span&gt;ssh-copy-id pi@piserver
&lt;span class=&#34;ln&#34;&gt;4&lt;/span&gt;ssh-copy-id pi@picamera01
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;ansible-installation&#34;&gt;Ansible Installation&lt;/h2&gt;
&lt;p&gt;Nun kann Ansible mit &lt;code&gt;apt install ansible&lt;/code&gt; installiert werden. Dies ist allerdings die etwas ältere Version 2.7.7. Die aktuellste könnte mit pip3 installiert werden. Ich habe allerdings darauf verzichtet und benutze die Version Der Distribution.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;sudo apt-get install python3-pip
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;pip3 install --user ansible
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;ansible-konfiguration&#34;&gt;Ansible Konfiguration&lt;/h2&gt;
&lt;p&gt;Nun gibt man die Host in der Datei &amp;quot;etc/ansible/hosts&amp;quot; an. Man kann sie gleich in Gruppen zusammenfassen um später Aktionen für alle Clients einer Gruppe zu starten.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;[pis]
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;homeautomation
&lt;span class=&#34;ln&#34;&gt;3&lt;/span&gt;piserver
&lt;span class=&#34;ln&#34;&gt;4&lt;/span&gt;picamera01
&lt;span class=&#34;ln&#34;&gt;5&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;6&lt;/span&gt;[picams]
&lt;span class=&#34;ln&#34;&gt;7&lt;/span&gt;picamera01
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Mit dem Befehl &lt;code&gt;ansible all --list-hosts&lt;/code&gt; können alle Hosts aufgelistet und damit die Konfigurationsdatei überprüft werden.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;  hosts (3):
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;    homeautomation
&lt;span class=&#34;ln&#34;&gt;3&lt;/span&gt;    piserver
&lt;span class=&#34;ln&#34;&gt;4&lt;/span&gt;    picamera01
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Da wir nur mit Raspberry Pis arbeiten, kann man als user pi verwenden. Das hat Gegenüber root den Nachteil, dass man Befehle oft mit sudo ausführen muss.
Allerdings entspricht der pi Benutzer dem üblichen Vorgang.
Der Benutzer für den SSH Zugang wird in die Datei &amp;quot;/etc/ansible/ansible.cf&amp;quot; eingetragen&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt; remote_user = pi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Nun kann man bereits den ersten Befehl &lt;code&gt;ansible all -m ping&lt;/code&gt; ausprobieren. Wenn alles korrekt eingerichtet und die SSH-Keys übertagen wurden wird der Befehl erfolgreich ausgeführt.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 1&lt;/span&gt;piserver | SUCCESS =&amp;gt; {
&lt;span class=&#34;ln&#34;&gt; 2&lt;/span&gt;    &amp;#34;changed&amp;#34;: false,
&lt;span class=&#34;ln&#34;&gt; 3&lt;/span&gt;    &amp;#34;ping&amp;#34;: &amp;#34;pong&amp;#34;
&lt;span class=&#34;ln&#34;&gt; 4&lt;/span&gt;}
&lt;span class=&#34;ln&#34;&gt; 5&lt;/span&gt;homeautomation | SUCCESS =&amp;gt; {
&lt;span class=&#34;ln&#34;&gt; 6&lt;/span&gt;    &amp;#34;changed&amp;#34;: false,
&lt;span class=&#34;ln&#34;&gt; 7&lt;/span&gt;    &amp;#34;ping&amp;#34;: &amp;#34;pong&amp;#34;
&lt;span class=&#34;ln&#34;&gt; 8&lt;/span&gt;}
&lt;span class=&#34;ln&#34;&gt; 9&lt;/span&gt;picamera01 | SUCCESS =&amp;gt; {
&lt;span class=&#34;ln&#34;&gt;10&lt;/span&gt;    &amp;#34;changed&amp;#34;: false,
&lt;span class=&#34;ln&#34;&gt;11&lt;/span&gt;    &amp;#34;ping&amp;#34;: &amp;#34;pong&amp;#34;
&lt;span class=&#34;ln&#34;&gt;12&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;ansible-playbook&#34;&gt;Ansible Playbook&lt;/h2&gt;
&lt;p&gt;Playbooks sind Anweisungs-Dateien die ein oder mehrere Befehlr enthalten, die auf den Clients ausgeführt werden sollen. Als Beispiel gibt es ein upgrade Playbook und ein reboot Playbook.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Playbook upgrade:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 1&lt;/span&gt;---
&lt;span class=&#34;ln&#34;&gt; 2&lt;/span&gt;- hosts: all
&lt;span class=&#34;ln&#34;&gt; 3&lt;/span&gt;  tasks:
&lt;span class=&#34;ln&#34;&gt; 4&lt;/span&gt;    - name: Wait for automatic system updates
&lt;span class=&#34;ln&#34;&gt; 5&lt;/span&gt;      shell: while sudo fuser /var/lib/dpkg/lock &amp;gt;/dev/null 2&amp;gt;&amp;amp;1; do sleep 1; done;
&lt;span class=&#34;ln&#34;&gt; 6&lt;/span&gt;    - name: apt-get update &amp;amp;&amp;amp; apt-get upgrade
&lt;span class=&#34;ln&#34;&gt; 7&lt;/span&gt;      sudo: yes
&lt;span class=&#34;ln&#34;&gt; 8&lt;/span&gt;      apt:
&lt;span class=&#34;ln&#34;&gt; 9&lt;/span&gt;        upgrade: &amp;#34;yes&amp;#34;
&lt;span class=&#34;ln&#34;&gt;10&lt;/span&gt;        update_cache: &amp;#34;yes&amp;#34;
&lt;span class=&#34;ln&#34;&gt;11&lt;/span&gt;        cache_valid_time: 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Playbook reboot:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 1&lt;/span&gt;---
&lt;span class=&#34;ln&#34;&gt; 2&lt;/span&gt;- hosts: all
&lt;span class=&#34;ln&#34;&gt; 3&lt;/span&gt;  tasks:
&lt;span class=&#34;ln&#34;&gt; 4&lt;/span&gt;    - name: Reboot host
&lt;span class=&#34;ln&#34;&gt; 5&lt;/span&gt;      sudo: yes
&lt;span class=&#34;ln&#34;&gt; 6&lt;/span&gt;      shell: sleep 2 &amp;amp;&amp;amp; /sbin/shutdown -r now &amp;#34;Ansible reboot&amp;#34;
&lt;span class=&#34;ln&#34;&gt; 7&lt;/span&gt;      async: 1
&lt;span class=&#34;ln&#34;&gt; 8&lt;/span&gt;      poll: 0
&lt;span class=&#34;ln&#34;&gt; 9&lt;/span&gt;    - name: Wait for host to come back up
&lt;span class=&#34;ln&#34;&gt;10&lt;/span&gt;      become: false
&lt;span class=&#34;ln&#34;&gt;11&lt;/span&gt;      wait_for_connection:
&lt;span class=&#34;ln&#34;&gt;12&lt;/span&gt;        delay: 15
&lt;span class=&#34;ln&#34;&gt;13&lt;/span&gt;        sleep: 2
&lt;span class=&#34;ln&#34;&gt;14&lt;/span&gt;        timeout: 120
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Nun kann man die Playbooks ausführen:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;ansible-playbook upgrade 
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;ansible-playbook reboot 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
        
      </description>
    </item>
    
    <item>
      <title>Raspberry Pi Werkzeuge</title>
      <link>https://mstroh76.github.io/Blog/post/tools/</link>
      <pubDate>Wed, 14 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://mstroh76.github.io/Blog/post/tools/</guid>
      <description>
        
          &lt;p&gt;Der Raspberry Pi ist eine ganz spezielle Computerhardware, so gibt es auch Werkzeuge die speziell für den Raspberry Pi gemacht oder angepasst wurden. Die folgende Liste stellt einige von ihnen vor.&lt;/p&gt;
&lt;h2 id=&#34;beschreibung&#34;&gt;Beschreibung&lt;/h2&gt;
&lt;p&gt;Auch wenn es inzwischen viele verschiedene Einplatinencomputer gibt, so ist der Raspberry Pi doch sehr speziell. Der SoC und die enthaltene Grafikkarte ist kaum wo anders in Einsatz.
Daher gibt es speziell an die Raspberry Pi und der GPU angepasste Werkzeuge. Die folgende List ist sicher nicht komplett aber einige Werkzeuge sind mir unter gekommen, die ich besonders gerne einsetze.&lt;/p&gt;
&lt;h2 id=&#34;software&#34;&gt;Software&lt;/h2&gt;
&lt;h3 id=&#34;screenshot---raspi2png&#34;&gt;Screenshot - raspi2png&lt;/h3&gt;
&lt;p&gt;Mit &lt;a href=&#34;https://github.com/GrazerComputerClub/raspi2png&#34;&gt;raspi2png&lt;/a&gt; kann man Screenshots im PNG-Format erzeugen. Das besondere daran ist, dass es direkt mit der GPU der Raspberry Pi zusammenarbeitet.
Dadurch kann es auch Screenshots erzeugen wo andere Programme wie z.B. &lt;a href=&#34;https://wiki.ubuntuusers.de/Scrot/&#34;&gt;scrot&lt;/a&gt; nicht funktionieren. Das ist bei allen Programm der Fall die direkt in der GPU arbeiten. Videos abspielen und Minecraft Pi sind solche Anwendungen bei denen nur raspi2png funktioniert.&lt;br&gt;
Das Programm war nicht optimal für den Einsatz mit einem Hotkey ausgelegt und so habe ich es kurzerhand erweitert und optimiert. Darum empfehle ich auch den Fork der auf der Git-Hub Seite des Grazer Computer Clubs liegt. Das originale Projekt ist auf &lt;a href=&#34;https://github.com/AndrewFromMelbourne/raspi2png&#34;&gt;https://github.com/AndrewFromMelbourne/raspi2png&lt;/a&gt; verfügbar.&lt;/p&gt;
&lt;h3 id=&#34;vnc-server---dispmanx_vnc&#34;&gt;VNC Server - dispmanx_vnc&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/patrikolausson/dispmanx_vnc&#34;&gt;dispmanx_vnc&lt;/a&gt; ist eine &lt;a href=&#34;https://de.wikipedia.org/wiki/Virtual_Network_Computing&#34;&gt;VNC Server&lt;/a&gt; mit dem man die grafische Oberfläche auf einen VNC-Client übertragen kann. Es gibt natürlich andere VNC Server, die allerings unter X11 laufen. dispmanx_vnc stellt direkt den Inhalt der GPU zur Verfügung. Das hat zum einen den Vorteil der guten Performance aber der Hauptgrund warum das Tool so besonders ist, ist das es in jeder Situation funktioniert. Ob man sich in der Konsole oder in X11 befindet ist egal, ob eine Video abgespielt wird oder Minecraft Pi gespielt wird - egal - die Übertragung per VNC funktioniert. Sogar eine Kodi Oberflache kann übertragen werden.&lt;br&gt;
Allerdings hat das Programm auch Nachteile. Das Projekt wurde von &lt;a href=&#34;https://github.com/hanzelpeter/dispmanx_vnc&#34;&gt;https://github.com/hanzelpeter/dispmanx_vnc&lt;/a&gt; geforkt und verbessert. Allerdings wurde die Lizenz entfernt was nun dazu führt, dass es eigentlich nicht mehr unter einen freien Lizenz verfügbar ist. Das originale Projekt kann man aber nicht empfehlen. Weiters wurden die Umsetzung der Tastencodes wenn der VNC-Client eingaben tätig, fix kodiert. Das bewirkt, dass immer ein amerikanisches Tastaturlayout verwendet wird und dieses noch zusätzlich nicht komplett umgesetzt wurde.
Aufgrund des Lizenzproblem kann ich auch das Problem nicht beheben.&lt;br&gt;
Dennoch für die Weiterleitung der grafische Oberfäche ist es aufgrund der Performance und universellen Einsetzbarkeit der VNC Server den ich empfehlen würde. Auf dem Blog des Grazer Computer Clubs gibt es einen Beitrag &lt;a href=&#34;https://blog.gc2.at/post/vnc/&#34;&gt;VNC - Virtual Network Computing&lt;/a&gt; speziell zu dem Programm.&lt;/p&gt;
&lt;h3 id=&#34;hotkey---triggerhappy&#34;&gt;Hotkey - triggerhappy&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://manpages.ubuntu.com/manpages/precise/man1/thd.1.html&#34;&gt;triggerhappy&lt;/a&gt; ist nichts Raspberry Pi spezifisches, es ist aber auf Raspberry Pi OS vorinstalliert. Das Programm ermöglicht es Tastatur-Hotkeys zu definieren ohne das X11 oder ähnliches läuft. Damit kann man z. B. Multimedia-Tasten wie Lauter und Leiser auch auf einem Raspberry Pi zum Funktionieren bringen.
Auch hierzu gibt es auf dem Blog des Grazer Computer Clubs den Beitrag &lt;a href=&#34;https://blog.gc2.at/post/hotkeys-zuweisen-ohne-x11/&#34;&gt;Hotkeys zuweisen ohne X11&lt;/a&gt; speziell zu dem Programm.&lt;/p&gt;
&lt;h3 id=&#34;system-monitorprozessmanager---htop&#34;&gt;System Monitor/Prozessmanager - htop&lt;/h3&gt;
&lt;p&gt;htop ist eine altbekanntes Diagnose Program bzw. Prozessmanager. In letzter Zeit ist nun wieder dynamik in die Entwicklung gekommen, nachdem lange Zeit nicht passiert ist. Das Projekt ist nun auf &lt;a href=&#34;https://github.com/htop-dev/htop&#34;&gt;https://github.com/htop-dev/htop&lt;/a&gt; verfügbar und mitlerweile auf Version 3. Es kursieren aber noch einige Forks. Besonders die Armbian Version sticht durch zusätzlich Features für ARM Prozessoren heraus. Es ist nun möglich die aktuelle CPU-Frequenz und CPU-Temperatur im Kopf anzeigen zu lassen. Vor vielen Jahren wurde bereits so eine Version für den Raspberry Pi vorgestellt. Auf &lt;a href=&#34;https://github.com/hishamhm/htop&#34;&gt;https://github.com/hishamhm/htop&lt;/a&gt; ist sie zu finden. Sie basiert allerdings auf einer alten htop Version 2 von 2018. Sie gilt aktuell also nur noch als Archiv.&lt;br&gt;
Ausgehend von dieser Version haben ich auch einige Änderungen eingebraucht, die vorallem die Farben für die Anzeige der CPU-Temperatur und CPU-Frequenz anpassen soll. Inwieweit diese Änderungen auch in einer Version 3 enthalten sind, bzw. übernehmbar wären, ist mir nicht bekannt. Aktuell wird bei Raspberry Pi OS aber die alte Version 2 eingesetzt und so kann ein Update auf die Version vom Grazer Computer Club einen Mehrwert bringen. Sie ist unter &lt;a href=&#34;https://github.com/GrazerComputerClub/htop&#34;&gt;https://github.com/GrazerComputerClub/htop&lt;/a&gt; verfügbar. Im übrigen kann man die neuen Anzeigen mit der Taste F2 hinzufügen!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/htop_Pi1.png&#34; alt=&#34;htop Raspberry Pi 1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;sd-karten-schreiben---raspberry-pi-imager-und-usb-imager&#34;&gt;SD Karten Schreiben - Raspberry Pi Imager und USB Imager&lt;/h3&gt;
&lt;p&gt;Lange Zeit hatte es keine sinnvolles Werkzeug zum Beschreiben einer SD-Karte unter Linux gegeben. Das Programm wird benötigt um ein Raspberry Pi Image bzw. Betriebssystem Image auf die SD-Karte zu bringen. Anfänglich musste man dd verwenden, das für Anfänger einfach zu viele Gefahren birgt. Danach kamm das Programm etcher, dass den Vorgang wesentlich sicherer und einfacher machte. Das Programm selbst ist aber etwas zwielichtig. Es ist riesig (&amp;gt; 100 MB) und muss als eigenständiges Programm heruntergeladen und ausgeführt werden.&lt;br&gt;
Nun gibt es endlich das Programm Raspberry Pi Imager und USB Imager, dass diesen Dienst verrichtet und nur minimale Anforderungen stellt. Ich würde Raspberry Pi Imager empfehlen. Es bietet zusätzlich die Möglichkeit weitere Einstellungen für das Betriebssystem vorzunehmen. Dazu gehört z.B. die Aktivierung des SSH-Dienstes, inklusive einem Passwort für den Benutzer Pi. Dann können die Ländereinstellungen inkl. Tastaturlayout definiert werden. Auch ein WLAN Netzwerk kann für den ersten Start bereits parametriert werden. Früher musste man um zum Einstellungsfenster zu kommen erst Strg+Shift+X drücken. Ab der Version 1.7 gibt es eine leicht ersichliche Schaltfläche mit einem Zahnrad.&lt;br&gt;
Das Programm unterstützt auch komprimierte Images mit der Extention gz, zip, xz und zst.&lt;br&gt;
Zur Installation kann man einfach das deb-Paket herunterladen und mit &lt;code&gt;sudo apt install ./imager_1.7.1_amd64.deb&lt;/code&gt; installieren.&lt;/p&gt;
&lt;p&gt;Raspberry Pi Imager - &lt;a href=&#34;https://www.raspberrypi.org/software/&#34;&gt;https://www.raspberrypi.org/software/&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;../../images/Raspberry_Pi_Imager_v1.7.1.png&#34; alt=&#34;Raspberry Pi Imager Dialog&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/Raspberry_Pi_Imager_v1.7.1_Einstellungen.png&#34; alt=&#34;Raspberry Pi Imager Einstellungsfenter Strg+Shift+X&#34;&gt;&lt;/p&gt;
&lt;p&gt;USB Imager - &lt;a href=&#34;https://gitlab.com/bztsrc/usbimager&#34;&gt;https://gitlab.com/bztsrc/usbimager&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;../../images/USBImager_1.0.6.png&#34; alt=&#34;USB Imager Dialog&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;spi-lcd-tft-anzeige---fbcp-ili9341&#34;&gt;SPI LCD-TFT Anzeige - fbcp-ili9341&lt;/h3&gt;
&lt;p&gt;Bei Kernel 4 konnte man noch einen SPI LCD-TFT Display über ein Kernel Modul ansprechen. Leider ist das mit Kernel 5 nun nicht mehr möglich. Zum Glück gibt es aber ein Programm mit dem verwirrenden Namen &lt;a href=&#34;https://github.com/juj/fbcp-ili9341&#34;&gt;fbcp-ili9341&lt;/a&gt;. fbcp steht dabei für Framebuffer copy und ili9341 für den gleichnamigen SPI Display Controller. Das Programm kann also den Inhalt der Grafikkarte (Framebuffer) über den SPI-Bus auf das LCD-TFT Display übertragen. Das ganze läuft nun etwas langsamer als früher im Userspace, kann aber überzeugen.&lt;br&gt;
Auch hierzu gibt es auf dem Blog des Grazer Computer Clubs den Beitrag &lt;a href=&#34;https://blog.gc2.at/post/spi-tft-lcd-kernel5/&#34;&gt;SPI TFT LCD - Kernel 5&lt;/a&gt;. Im übrigen Unterstützt das Programm auch andere SPI-Controller wie ST7735R und ST7789VW.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/fbcp-ili9341.jpg&#34; alt=&#34;fbcp-ili9341 sowie dispmanx_vnc im Einsatz&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;serieller-terminal-client---screen&#34;&gt;(Serieller) Terminal Client - screen&lt;/h3&gt;
&lt;p&gt;screen ist eigentlich ein Programm das mehrere Terminals verwalten kann. Es ist kein reines Werkzeug für den Raspberry Pi sondern ist praktisch auf allen Linux Systemen verfügbar.&lt;br&gt;
Nicht so bekannt ist allerdings die Möglichkeit screen auch für serielle Terminals zu verwenden. Dazu muss man einfach die serielle Schnittstelle bzw. das Linux-Device als Parameter angeben. Beim Raspberry Pi ist das typischerweise &lt;code&gt;/dev/ttyAMA0&lt;/code&gt; (sofern die serielle Schnittstelle aktiviert ist) und  &lt;code&gt;/dev/ttyUSB0&lt;/code&gt; bei einem USB-Adapter.
Optional kann man auch die Baudrate für die Verbindung mit angeben.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;screen /dev/ttyAMA0 115200&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Benötigt wird dies z.B. wenn man sich per serielle Schnittstelle auf einen Raspberry Pi Zero V1.3 verbinden möchte. Ihm fehlt es ja an einer LAN und WLAN Kommunikationsmöglichkeit.&lt;br&gt;
Aber Achtung dieser Terminal ist nicht exakt gleich wie ein ssh-Terminal. Es werden z.B. keine Farben unterstützt.&lt;/p&gt;
&lt;h2 id=&#34;hardware&#34;&gt;Hardware&lt;/h2&gt;
&lt;h3 id=&#34;serielleruart-usb-adapter&#34;&gt;Serieller/UART USB-Adapter&lt;/h3&gt;
&lt;p&gt;Wie man beim Software Werkzeug screen gesehen hat, ist eine serielle Verbindung zu manchen Geräten wie einem Raspberry Pi Zero V1.3 oder einem Microkontroller (z.B. ESP-01 oder Blue Pill) ganz nützlich.&lt;br&gt;
Daher würde ich jeder Bastlerin und jedem Bastler empfehlen einen USB-TTL-Seriell Adapter bzw. &amp;quot;USB to TTL serial cable&amp;quot; in die Werkzeugkiste zu geben. Beispielweise einer mit dem Chipsatz CP2102. Optimalerweise arbeitet der USB-Adapter mit 3,3 V Signalspannung und kann direkt 3,3 V und 5 V Betriebsspannug bereitstellen. Wenn er dann auf Linux und Windows direkt unterstützt wird, ist alles perfekt.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/CP2102.jpg&#34; alt=&#34;USB TTL serieller Adapter mit Chipsatz CP2102&#34;&gt;&lt;/p&gt;
        
      </description>
    </item>
    
    <item>
      <title>Raspberry Pi 400 - Review</title>
      <link>https://mstroh76.github.io/Blog/post/pi400/</link>
      <pubDate>Thu, 04 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://mstroh76.github.io/Blog/post/pi400/</guid>
      <description>
        
          &lt;p&gt;Der neue Raspberry Pi 400 ist eine kompakte Tastatur mit integrierter verbesserter Raspberry Pi 4 Hardware, hier ein paar alternative Infos dazu ...&lt;/p&gt;
&lt;h2 id=&#34;beschreibung&#34;&gt;Beschreibung&lt;/h2&gt;
&lt;p&gt;Das neueste Produkt der Raspberry Pi (Trading) Ltd. ist eine kompakte Tastatur, in der Raspberry Pi 4 Hardware integriert wurde. Es wurde eine verbesserte Version (Revision) des SoC BCM2711 mit der Zusatzbezeichung C0 eingebaut. Die Taktrate wurde also im Vergleich zum Pi 4 mit Revision B0 von 1,5 GHz auf 1,8 GHz erhöht. Es stehen 4 GB RAM zur Verfügung. Die Anschlüsse sind zum Pi 4 identisch, außer dass ein USB 2.0 Anschluss weniger vorhanden ist. Der Anschluss für die Kamera und Display ist beim Pi 400 auch nicht vorhanden. Der Tastatur fehlt im Vergleich zu einer standard Tastatur der Nummern-Block. Dadurch ist die kompakte Größe möglich.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/Pi400-size.jpg&#34; alt=&#34;Pi 400 Vergleich zu einer standard Tastatur&#34;&gt;&lt;/p&gt;
&lt;p&gt;Angeboten wird der Pi 400 entweder als &amp;quot;nacktes System&amp;quot; also nur die Tastatur oder als Bundle mit Netzteil, Kabeln, Maus, SD-Karte und einer umfangreichen Dokumentation. Achtung bei der Bestellung auf das Tastaturlayout achten!&lt;/p&gt;
&lt;p&gt;Preis Bundle DE &lt;a href=&#34;https://geizhals.at/raspberry-pi-400-kit-raspberry-pi-400-de-kit-a2414639.html&#34;&gt;geizhals.at&lt;/a&gt;:  100-104 Euro&lt;br&gt;
Preis Pi400 DE &lt;a href=&#34;https://electronics.semaf.at/Raspberry-Pi-400&#34;&gt;semaf electronics&lt;/a&gt;:  ~78 Euro&lt;/p&gt;
&lt;h2 id=&#34;eckdaten&#34;&gt;Eckdaten&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;SoC&lt;/strong&gt;: Broadcom BCM2711C0 4 x ARM Cortex-A72 (ARMv8) 64-bit mit maximal 1,8 GHz Taktfrequenz&lt;br&gt;
&lt;strong&gt;GPU&lt;/strong&gt;: Broadcom VideoCore VI&lt;br&gt;
&lt;strong&gt;RAM&lt;/strong&gt;: 4GB LPDDR4 SDRAM&lt;br&gt;
&lt;strong&gt;WLAN&lt;/strong&gt;: 2.4 GHz und 5 GHz 802.11b/g/n/ac&lt;br&gt;
&lt;strong&gt;Bluetooth&lt;/strong&gt;: Version 5.0, Bluetooth Low Energy (BLE)&lt;br&gt;
&lt;strong&gt;LAN&lt;/strong&gt;: Gigabit Ethernet&lt;br&gt;
&lt;strong&gt;GPIO&lt;/strong&gt;: 40-pin GPIO header&lt;br&gt;
&lt;strong&gt;Festspeicher&lt;/strong&gt;: microSD-Steckplatz&lt;br&gt;
&lt;strong&gt;Anschlüsse:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1x USB Type-C Versorgung&lt;/li&gt;
&lt;li&gt;2x micro-HDMI 2.0&lt;/li&gt;
&lt;li&gt;1x USB 2.0&lt;/li&gt;
&lt;li&gt;2x USB 3.0&lt;/li&gt;
&lt;li&gt;1x RJ45 Ethernet&lt;/li&gt;
&lt;li&gt;1x Kensington-Schloss&lt;/li&gt;
&lt;li&gt;1x 40-Pin GPIO header&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Kühlung&lt;/strong&gt;: Interner passiver Kühlkörper&lt;br&gt;
&lt;strong&gt;Abmessungen&lt;/strong&gt;: 29 cm × 12 cm × 2,4 cm&lt;br&gt;
&lt;strong&gt;Gewicht&lt;/strong&gt;: 385 g&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Bundle Lieferumfang:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Raspberry Pi 400&lt;/li&gt;
&lt;li&gt;Raspberry Pi Maus&lt;/li&gt;
&lt;li&gt;Raspberry Pi offizielles Netzteil USB-C&lt;/li&gt;
&lt;li&gt;Micro-SD 16 GB&lt;/li&gt;
&lt;li&gt;Micro-HDMI auf HDMI-Kabel&lt;/li&gt;
&lt;li&gt;Raspberry Pi Beginner Guide&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;test&#34;&gt;Test&lt;/h2&gt;
&lt;p&gt;CNX: &lt;a href=&#34;https://www.cnx-software.com/2020/11/02/raspberry-pi-400-review-benchmarks-vs-raspberry-pi-4/&#34;&gt;Raspberry Pi 400 Keyboard PC Review and Benchmarks vs Raspberry Pi 4&lt;/a&gt;&lt;br&gt;
Michael Kofler: &lt;a href=&#34;https://kofler.info/raspberry-pi-400/&#34;&gt;RASPBERRY PI 400&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Abseits von den vielen Pi 400 Tests die ich gelesen habe, haben mich ein paar technische Dinge interessiert, die bisher nicht beleuchtet wurden. Diesen will ich mich nun widmen.&lt;/p&gt;
&lt;h3 id=&#34;lokalisierung&#34;&gt;Lokalisierung&lt;/h3&gt;
&lt;p&gt;Ich finde es immer etwas Absurd, dass es im Jahre 2021 noch immer nicht möglich ist, ein Tastaturlayout automatisch zu erkennen. Besonders sonderbar ist es, wenn die Tastatur selbst das Computersystem ist, wie bei Pi 400. Nach dem ersten Start wird man vor der Anmeldung gebeten die Lokalisierungeinstellungen zu tätigen. Das passt ganz gut, so kann man das deutsche Layout bereits vor der Passworteingabe setzen. Später kann man dann gleich &amp;quot;raspberry&amp;quot; als Passwort eingeben und nicht wie bei der Raspberry Pi OS Lite Version &amp;quot;raspberrz&amp;quot;.&lt;br&gt;
Allerdings relativiert sich der Eindruck dann gleich wieder, den die Tastatureinstellung gilt nur für die grafische Oberfläche. Wechselt man mit Strg+Alt+F1 auf die Konsole, so ist das englische Layout aktiv. Nun muss man nochmal die Lokalisierungseinstellungen bei Konfigurationstool &lt;code&gt; rasp-config&lt;/code&gt; eingeben, damit alles passt.&lt;/p&gt;
&lt;h3 id=&#34;geschwindigkeit-sd-karte&#34;&gt;Geschwindigkeit SD-Karte&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;../../images/Pi400-SDcard.jpg&#34; alt=&#34;Sandisk Edge SD-Karte vom Bundle&#34;&gt;&lt;/p&gt;
&lt;p&gt;Da bei Bundle eine SD-Karte dabei ist, fragt man sich wie gut die eigentlich ist und ob eine SSD am USB 3.0 bessere Performancewerte hat.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/Pi400-IO_4Krandom.png&#34; alt=&#34;4 KByte zufälliger Zugriff&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/Pi400-IO_512Kseq.png&#34; alt=&#34;512 KByte sequentieller Zugriff&#34;&gt;&lt;/p&gt;
&lt;p&gt;Der Test zeigt das die eingesetzte SD-Karte recht schnell ist. 40 MB/s für lesenden Zugriff ist schon ordentlich. Das ist fast doppelt, so hoch als meine bisherige Sandisk Ultra Karte.
Schaut man sich aber die Werte der Samsung 840 Pro SSD am USB an, so spielt diese doch in einer ganz anderen Liga. Besonders die Schreibzugriff liegen um Faktoren höher.&lt;/p&gt;
&lt;h3 id=&#34;cpu&#34;&gt;CPU&lt;/h3&gt;
&lt;p&gt;Der neue Prozessor im SOC taktet nun maximal mit 1,8 statt 1,5 GHz. Also ist die Performance um 20 % erhöht. dazu bedarf es keines Tests. Dennoch interessiert mich der Vergleich zu Intel Prozessoren.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/Pi400-CPUBenchmark.png&#34; alt=&#34;CPU Benchmark Vergleich&#34;&gt;&lt;/p&gt;
&lt;p&gt;Die Frage ist aber auch, wird die Takterhöhung des neunen Kerns ohne erhöhung der Spannung erreicht? Bzw. kann der Raspberry Pi 4 auch mit 1,8 GHz betrieben werden?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Pi 400:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Bei maximaler CPU-Last und damit Taktrate liegt die CPU-Spannung bei maximal &lt;strong&gt;0,92 V&lt;/strong&gt; und im Leerlauf bei 0,8833 V.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;HW Block:&lt;/th&gt;
&lt;th&gt;ARM&lt;/th&gt;
&lt;th&gt;Core&lt;/th&gt;
&lt;th&gt;H264&lt;/th&gt;
&lt;th&gt;SDRAM&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Min Freq:&lt;/td&gt;
&lt;td&gt;600MHz&lt;/td&gt;
&lt;td&gt;250MHz&lt;/td&gt;
&lt;td&gt;0MHz&lt;/td&gt;
&lt;td&gt;3180MHz&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Max Freq:&lt;/td&gt;
&lt;td&gt;1800MHz&lt;/td&gt;
&lt;td&gt;500MHz&lt;/td&gt;
&lt;td&gt;500MHz&lt;/td&gt;
&lt;td&gt;3180MHz&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Pi 4:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Beim Pi 4 liegt die CPU-Spannung fix bei bei &lt;strong&gt;0,8875 V&lt;/strong&gt;. Die höhere Taktrate des Pi 400 wird also durch Erhöhung der CPU-Spannung erreicht!&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;HW Block:&lt;/th&gt;
&lt;th&gt;ARM&lt;/th&gt;
&lt;th&gt;Core&lt;/th&gt;
&lt;th&gt;H264&lt;/th&gt;
&lt;th&gt;SDRAM&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Min Freq:&lt;/td&gt;
&lt;td&gt;600MHz&lt;/td&gt;
&lt;td&gt;250MHz&lt;/td&gt;
&lt;td&gt;0MHz&lt;/td&gt;
&lt;td&gt;3180MHz&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Max Freq:&lt;/td&gt;
&lt;td&gt;1500MHz&lt;/td&gt;
&lt;td&gt;500MHz&lt;/td&gt;
&lt;td&gt;500MHz&lt;/td&gt;
&lt;td&gt;3180MHz&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Pi 4 overclocked:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Den Raspberry Pi 4 kann man durch eine Spannungserhöhung mit Faktor 3 (0,075 V) auch stabil auf 1,8 GHz betrieben. Dann läuft er mit &lt;strong&gt;0.9563 V&lt;/strong&gt; und damit etwas höher (~0,04 V) als die CPU vom Pi 400.&lt;/p&gt;
&lt;p&gt;config.txt:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;#uncomment to overlock the arm. 1800 MHz is the default.
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;over_voltage=3
&lt;span class=&#34;ln&#34;&gt;3&lt;/span&gt;arm_freq=1800
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Mehr zum Thema Übertakten des Raspberry Pi 4 kannst du bei &lt;a href=&#34;https://magpi.raspberrypi.org/articles/how-to-overclock-raspberry-pi-4&#34;&gt;How to overclock Raspberry Pi 4&lt;/a&gt; finden.&lt;/p&gt;
&lt;h3 id=&#34;temperatur&#34;&gt;Temperatur&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;../../images/Pi400-Temp.png&#34; alt=&#34;CPU-Temperatur bei Vollast&#34;&gt;&lt;/p&gt;
&lt;p&gt;Wie der Temperaturaufzeichnung im Vollastbetrieb zeigt, bleibt die CPU-Temperatur immer im grünen Bereich. Die interne passive Kühlung ist optimal ausgelegt.&lt;/p&gt;
&lt;h3 id=&#34;wiringpi-library&#34;&gt;WiringPi Library&lt;/h3&gt;
&lt;p&gt;Die WiringPi Library ist eine weit verbreitete C-Bibliothek für die GPIOs des Raspberry Pis. Sie wurde Ursprünglich von Gordon Henderson programmiert. Er Unterstützt das Projekt inzwischen nicht mehr. Dadurch unterstützt die Library den Raspberry Pi 4 und Pi 400 in der vorinstallieren Version nicht! Bei Veröffentlichung des Pi 4 Computers hat er noch eine allerletzte Version 2.52 auf seiner &lt;a href=&#34;http://wiringpi.com/wiringpi-updated-to-2-52-for-the-raspberry-pi-4b/&#34;&gt;Webseite&lt;/a&gt; veröffentlicht. Unverständlicherweise ist aber bei Raspberry Pi OS nur die Version 2.50 verfügbar.
Aber auch wenn man die Version 2.52 nachinstalliert, so gibt es keine Erkennung für den Pi 400.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 1&lt;/span&gt;gpio version: 2.50
&lt;span class=&#34;ln&#34;&gt; 2&lt;/span&gt;Copyright (c) 2012-2018 Gordon Henderson
&lt;span class=&#34;ln&#34;&gt; 3&lt;/span&gt;This is free software with ABSOLUTELY NO WARRANTY.
&lt;span class=&#34;ln&#34;&gt; 4&lt;/span&gt;For details type: gpio -warranty
&lt;span class=&#34;ln&#34;&gt; 5&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 6&lt;/span&gt;Raspberry Pi Details:
&lt;span class=&#34;ln&#34;&gt; 7&lt;/span&gt;  Type: Unknown19, Revision: 00, Memory: 0MB, Maker: Sony 
&lt;span class=&#34;ln&#34;&gt; 8&lt;/span&gt;  * Device tree is enabled.
&lt;span class=&#34;ln&#34;&gt; 9&lt;/span&gt;  *--&amp;gt; Raspberry Pi 400 Rev 1.0
&lt;span class=&#34;ln&#34;&gt;10&lt;/span&gt;  * This Raspberry Pi supports user-level GPIO access.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Zum Glück gibt es aber inzwischen ein Git-Hub &lt;a href=&#34;https://github.com/WiringPi/WiringPi&#34;&gt;WiringPi&lt;/a&gt; Projekt, das die Library weiter wartet. Hier ist die Version 2.60 verfügbar, die keine Probleme mit der neuen Hardware hat!&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 1&lt;/span&gt;gpio version: 2.60
&lt;span class=&#34;ln&#34;&gt; 2&lt;/span&gt;Copyright (c) 2012-2018 Gordon Henderson
&lt;span class=&#34;ln&#34;&gt; 3&lt;/span&gt;This is free software with ABSOLUTELY NO WARRANTY.
&lt;span class=&#34;ln&#34;&gt; 4&lt;/span&gt;For details type: gpio -warranty
&lt;span class=&#34;ln&#34;&gt; 5&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 6&lt;/span&gt;Raspberry Pi Details:
&lt;span class=&#34;ln&#34;&gt; 7&lt;/span&gt;  Type: Pi 400, Revision: 00, Memory: 4096MB, Maker: Sony 
&lt;span class=&#34;ln&#34;&gt; 8&lt;/span&gt;  * Device tree is enabled.
&lt;span class=&#34;ln&#34;&gt; 9&lt;/span&gt;  *--&amp;gt; Raspberry Pi 400 Rev 1.0
&lt;span class=&#34;ln&#34;&gt;10&lt;/span&gt;  * This Raspberry Pi supports user-level GPIO access.
&lt;span class=&#34;ln&#34;&gt;11&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;12&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;13&lt;/span&gt;+-----+-----+---------+------+---+---Pi 400-+---+------+---------+-----+-----+
&lt;span class=&#34;ln&#34;&gt;14&lt;/span&gt; | BCM | wPi |   Name  | Mode | V | Physical | V | Mode | Name    | wPi | BCM |
&lt;span class=&#34;ln&#34;&gt;15&lt;/span&gt; +-----+-----+---------+------+---+----++----+---+------+---------+-----+-----+
&lt;span class=&#34;ln&#34;&gt;16&lt;/span&gt; |     |     |    3.3v |      |   |  1 || 2  |   |      | 5v      |     |     |
&lt;span class=&#34;ln&#34;&gt;17&lt;/span&gt; |   2 |   8 |   SDA.1 |   IN | 1 |  3 || 4  |   |      | 5v      |     |     |
&lt;span class=&#34;ln&#34;&gt;18&lt;/span&gt; |   3 |   9 |   SCL.1 |   IN | 1 |  5 || 6  |   |      | 0v      |     |     |
&lt;span class=&#34;ln&#34;&gt;19&lt;/span&gt; |   4 |   7 | GPIO. 7 |   IN | 1 |  7 || 8  | 1 | IN   | TxD     | 15  | 14  |
&lt;span class=&#34;ln&#34;&gt;20&lt;/span&gt; |     |     |      0v |      |   |  9 || 10 | 1 | IN   | RxD     | 16  | 15  |
&lt;span class=&#34;ln&#34;&gt;21&lt;/span&gt; |  17 |   0 | GPIO. 0 |   IN | 0 | 11 || 12 | 0 | IN   | GPIO. 1 | 1   | 18  |
&lt;span class=&#34;ln&#34;&gt;22&lt;/span&gt; |  27 |   2 | GPIO. 2 |   IN | 0 | 13 || 14 |   |      | 0v      |     |     |
&lt;span class=&#34;ln&#34;&gt;23&lt;/span&gt; |  22 |   3 | GPIO. 3 |   IN | 0 | 15 || 16 | 0 | IN   | GPIO. 4 | 4   | 23  |
&lt;span class=&#34;ln&#34;&gt;24&lt;/span&gt; |     |     |    3.3v |      |   | 17 || 18 | 0 | IN   | GPIO. 5 | 5   | 24  |
&lt;span class=&#34;ln&#34;&gt;25&lt;/span&gt; |  10 |  12 |    MOSI |   IN | 0 | 19 || 20 |   |      | 0v      |     |     |
&lt;span class=&#34;ln&#34;&gt;26&lt;/span&gt; |   9 |  13 |    MISO |   IN | 0 | 21 || 22 | 0 | IN   | GPIO. 6 | 6   | 25  |
&lt;span class=&#34;ln&#34;&gt;27&lt;/span&gt; |  11 |  14 |    SCLK |   IN | 0 | 23 || 24 | 1 | IN   | CE0     | 10  | 8   |
&lt;span class=&#34;ln&#34;&gt;28&lt;/span&gt; |     |     |      0v |      |   | 25 || 26 | 1 | IN   | CE1     | 11  | 7   |
&lt;span class=&#34;ln&#34;&gt;29&lt;/span&gt; |   0 |  30 |   SDA.0 |   IN | 1 | 27 || 28 | 1 | IN   | SCL.0   | 31  | 1   |
&lt;span class=&#34;ln&#34;&gt;30&lt;/span&gt; |   5 |  21 | GPIO.21 |   IN | 1 | 29 || 30 |   |      | 0v      |     |     |
&lt;span class=&#34;ln&#34;&gt;31&lt;/span&gt; |   6 |  22 | GPIO.22 |   IN | 1 | 31 || 32 | 0 | IN   | GPIO.26 | 26  | 12  |
&lt;span class=&#34;ln&#34;&gt;32&lt;/span&gt; |  13 |  23 | GPIO.23 |   IN | 0 | 33 || 34 |   |      | 0v      |     |     |
&lt;span class=&#34;ln&#34;&gt;33&lt;/span&gt; |  19 |  24 | GPIO.24 |   IN | 0 | 35 || 36 | 0 | IN   | GPIO.27 | 27  | 16  |
&lt;span class=&#34;ln&#34;&gt;34&lt;/span&gt; |  26 |  25 | GPIO.25 |   IN | 0 | 37 || 38 | 0 | IN   | GPIO.28 | 28  | 20  |
&lt;span class=&#34;ln&#34;&gt;35&lt;/span&gt; |     |     |      0v |      |   | 39 || 40 | 0 | IN   | GPIO.29 | 29  | 21  |
&lt;span class=&#34;ln&#34;&gt;36&lt;/span&gt; +-----+-----+---------+------+---+----++----+---+------+---------+-----+-----+
&lt;span class=&#34;ln&#34;&gt;37&lt;/span&gt; | BCM | wPi |   Name  | Mode | V | Physical | V | Mode | Name    | wPi | BCM |
&lt;span class=&#34;ln&#34;&gt;38&lt;/span&gt; +-----+-----+---------+------+---+---Pi 400-+---+------+---------+-----+-----+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;fazit&#34;&gt;Fazit&lt;/h2&gt;
&lt;p&gt;Der Sinn der Hardware erschließt sich mir kaum. Der angepeilte Nutzer soll wohl der Desktop Benutzer sein. Aber so einen Pi 400 kann man sich mit einem normalen Pi 4 leicht selbst zusammenstellen. Auch die 1,8 GHz können problemlos erreicht werden. Die Raspberry Pi Tastatur bekommt man für 25 Euro (inkl. integriertem USB Hub). Der Raspberry Pi 4 GB kostet ca. 57,5 Euro. Macht zusammen 82,5 Euro statt der 78 für den Pi 400. Mehr Sinn macht da schon das Bundle für ca. 100 Euro immerhin bekommt man dann, ein Netzteil, eine Maus und eine qualitativ hochwertige 16 GB SD-Karte dazu. Nicht zu vergessen auch noch das Handbuch. Da kommt man mit den einzelnen Komponenten knapp darüber.&lt;br&gt;
Also wenn schon Pi 400 dann als Bundle. Ich würde aber eher davon abraten und auf einen standard Raspberry Pi setzen, mit den Eingabegeräten seiner Wahl.
So kann man später die Hardware auch mal anders einsetzen als Server oder zur Homeautomation. Eine defekt Tastatur kann dann auch einfach ausgetauscht werden.&lt;/p&gt;
&lt;p&gt;Komplett überzeugend ist das interne passive Kühlsystem. Es führt dazu, dass das System absolut lautlos seinen Dienst verrichtet. Die CPU kommt nie in einen kritischen Temperaturbereich, sodass eine Taktreduzierung gefürchtet werden müsste.&lt;/p&gt;
&lt;p&gt;Was mich wirklich gestört hat, sind die Abstände zwischen den Anschlüssen auf der Hinterseite. Da relativ wenig Platz vorhanden ist, besonders wenn man Adapter für den Micro-HDMI Anschluss einsetzt. Des weiteren sind die Kabeln vom Bundle generell sehr dick und steif.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/Pi400-connect.jpg&#34; alt=&#34;Anschlüsse mit wenig Abstand&#34;&gt;
&lt;img src=&#34;../../images/Pi400-cable.jpg&#34; alt=&#34;Dicke steife Kabel&#34;&gt;&lt;/p&gt;
&lt;p&gt;Ich denke beim Pi 400 wurde auch einiges an Möglichkeiten vertan. Man hätte aus der Hardware so viel mehr machen können. Ein paar Beispiele:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;M2-SSD Slot&lt;/li&gt;
&lt;li&gt;Gesockelter SO-DIMM RAM&lt;/li&gt;
&lt;li&gt;Integriertes Display mit Touch Funktion (Touch Bar wie bei Apple MacBook Pro)&lt;/li&gt;
&lt;li&gt;Integriertes LEDs für einfache GPIO Aufgaben oder angepasster HAT beilegen&lt;/li&gt;
&lt;li&gt;Mikrofon und Line-in Eingang&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Zumindest hätte man intern ein Compute Modul einsetzen können, dann wäre ein Aktualisierung der Hardware möglich gewesen.&lt;br&gt;
Im übrigen gibt es keinen Display- und Kameraanschluss wie beim Pi 4.&lt;/p&gt;
&lt;p&gt;Naja, ansonsten ist das Produkt aber ganz solide und es macht auch Spaß damit zu arbeiten. Klar die Performance ist weit weg von der eines i7 Intel Laptops von vor 6 Jahren, aber dennoch kann damit durchaus gearbeitet werden. Ich persönlich bleibe aber lieber auf meinem System.&lt;/p&gt;
        
      </description>
    </item>
    
    <item>
      <title>STM32-O-Scope das &lt;10 Euro Osilloskop</title>
      <link>https://mstroh76.github.io/Blog/post/stm32-o-scope/</link>
      <pubDate>Sun, 31 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://mstroh76.github.io/Blog/post/stm32-o-scope/</guid>
      <description>
        
          &lt;p&gt;Mit einem günstigen STM32 Mikrocontroller und einen SPI-TFT-Display kann man einfaches Oszilloskop bauen. Hier erfährst du wie das geht...&lt;/p&gt;
&lt;h2 id=&#34;beschreibung&#34;&gt;Beschreibung&lt;/h2&gt;
&lt;p&gt;Das Projekt &lt;a href=&#34;https://github.com/pingumacpenguin/STM32-O-Scope&#34;&gt;STM32-O-Scope&lt;/a&gt; von pingumacpenguin macht aus einem günstigen STM32 Mikrocontroller System und einem SPI-TFT-Display ein einfaches Oszilloskop. Das Projekt ist extrem einfach aufgebaut. Leider wird die Firmware aber nur als Source bzw. Arduino IDE Projekt angeboten. Man muss sich also um die Konfiguration der Entwicklungsumgebung, um die Bibliotheken und die Kompilierung und schlussendlich den Flashvorgang selbst kümmern. Hier warten leider viele Hürden, also doch kein Projekt für Anfänger.
Die dazugehörige README und &lt;a href=&#34;https://github.com/pingumacpenguin/STM32-O-Scope/wiki&#34;&gt;Wiki-Seite&lt;/a&gt; helfen nämlich an den entscheidenden Stellen nicht weiter!
Eine weiter neuere Anleitung aus 2017 von satoshinm blog &lt;a href=&#34;https://satoshinm.github.io/blog/180105_stm32scope_building_an_amazing_10_oscilloscope_with_an_stm32_blue_pill_lcd_touchscreen_and_stm32-o-scope_software.html&#34;&gt;Building an Amazing $10 Oscilloscope with an STM32 blue pill, LCD touchscreen, and STM32-O-Scope software&lt;/a&gt; verbessert die Situation.
Hier ist die Pin-Belegung übersichtlich beschrieben. Aber das Kapitel &amp;quot;Compiling the software&amp;quot; enthält einige Anpassungen aber auch irrefürende Hinweise und führt Schlussendlich auch nicht zur fehlerfreien Kompilierung.&lt;/p&gt;
&lt;p&gt;Aus diesem Grund habe ich mich dazu entschlossen eine möglichst einfache detaillierte Schritt für Schritt Anleitung zu erstellen.&lt;/p&gt;
&lt;h2 id=&#34;komponenten&#34;&gt;Komponenten&lt;/h2&gt;
&lt;p&gt;Man benötigt für das Projekt lediglich:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;STM32F103C8T6 ARM STM32 Minimum System Development Board Module , China Preis ca. 2 Euro&lt;/li&gt;
&lt;li&gt;TFT Display mit ili9341 Chipsatz, 320x240 Auflösung (verfügbar mit 2.2, 2.4 oder 2.8 Zoll Größe ), China Preis 5-8 Euro&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://www.st.com/en/microcontrollers-microprocessors/stm32f103.html&#34;&gt;STM32F103&lt;/a&gt; ist eine Mikrocontroller von STMicrosystems mit einem ARM Cortex-M3 Prozessorkern. Die Taktrate beträgt maximal 72 MHz. Der Code &amp;quot;C8&amp;quot; im Namen bedeutet, dass 64 kByte Flash Speicher (undokumentiert oft auch 128 kByte verfügbar) und 20 kByte SRAM im IC vorhanden sind.
Die Systemplatine mit diesem IC wird für teilweise unter 2 Euro verkauft. Es wird auch mit dem Namen &amp;quot;blue pill&amp;quot; bezeichnet.  Mehr Informationen über das System findet man auf &lt;a href=&#34;http://stefanfrings.de/stm32/stm32f1.html#bluepill&#34;&gt;http://stefanfrings.de/stm32/stm32f1.html#bluepill&lt;/a&gt; . Aber Achtung, teilweise werden Nachbauten mit einem Clone IC verkauft. Dieser Chip fängt dann mit einer anderen Bezeichnung, wie &amp;quot;CH32&amp;quot; oder &amp;quot;CS32&amp;quot; an. &lt;strong&gt;Hände weg von diesen Clone Systemen!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Das Display mit dem ili9341 ist ein weit verbreiteter standard Typ mit SPI-Schnittstelle. Optional wird auch die Touch Funktion des Displays unterstützt. In dieser Anleitung wird sie aber nicht beachtet.&lt;/p&gt;
&lt;h2 id=&#34;anschluss&#34;&gt;Anschluss&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;STM32  Anschluss&lt;/th&gt;
&lt;th&gt;LCD Anschluss&lt;/th&gt;
&lt;th&gt;Beschreibung&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;A0&lt;/td&gt;
&lt;td&gt;D/C&lt;/td&gt;
&lt;td&gt;Data/Command&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;A1&lt;/td&gt;
&lt;td&gt;CS&lt;/td&gt;
&lt;td&gt;Chip select&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;A2&lt;/td&gt;
&lt;td&gt;RESET&lt;/td&gt;
&lt;td&gt;Reset&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;3.3&lt;/td&gt;
&lt;td&gt;LED&lt;/td&gt;
&lt;td&gt;Hintergrundbeleuchtung&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;A5&lt;/td&gt;
&lt;td&gt;SCK&lt;/td&gt;
&lt;td&gt;SPI Takt&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;A6&lt;/td&gt;
&lt;td&gt;SDO(MISO)&lt;/td&gt;
&lt;td&gt;SPI master input / slave output nur bei Touchfunktion&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;A7&lt;/td&gt;
&lt;td&gt;SDI(MOSI)&lt;/td&gt;
&lt;td&gt;SPI master output / slave input&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;G&lt;/td&gt;
&lt;td&gt;GND&lt;/td&gt;
&lt;td&gt;Ground&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;3.3&lt;/td&gt;
&lt;td&gt;VCC&lt;/td&gt;
&lt;td&gt;Versorgung&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Optional könnte man die Hintergrundbeleuchtung auch bei A3 Anschließen, allerdings ist die Stromaufnahme zumeist zu hoch für den Chip Ausgang (in meinen Fall 26 mA). Daher würde ich ihn fix auf 3,3 V legen. Ansonsten sollte man eine FET- oder Transistorschaltung vorsehen, sofern diese nicht im Display vorhanden ist.&lt;/p&gt;
&lt;p&gt;Der Anschluss B0 ist der Analoge Eingang des Oszilloskopes. Achtung der Eingang ist unbeschaltet nur für Spannungen von 0 bis 3,3 V geeignet!&lt;br&gt;
Am Ausgang B1 wird ein 500 Hz Rechtecksignal ausgegeben, das zu Verifikation verwendet werden kann. Eine Drahtbrücke von B0 zu B1 führt also zu Messen dieses Rechtecksignals. Dies sollte für den ersten Test durchgeführt werden.&lt;/p&gt;
&lt;h2 id=&#34;stm32duino-firmware-übertragen&#34;&gt;STM32duino Firmware übertragen&lt;/h2&gt;
&lt;p&gt;Bei den üblichen Anleitungen wird empfohlen STM32duino auf das System aufzuspielen. Das hat den Vorteil, dass ab dann das System direkt über den USB-Anschluss programmiert werden kann. Auf den ersten Blick eine Vorteil, allerdings benötigt die Firmware einen großen Teil vom Speicher und verringert also den nutzbaren Flash-Speicher unseres Programms.&lt;br&gt;
Bei mir hat das dann nicht funktioniert, ich vermute wegen zu wenig Speicher.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Das aufspielen der STM32duino Firmware ist also nicht nötig!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Auch wenn man die Firmware aufspielen möchte, so muss man zumindest bei ersten mal eine andere Möglichkeit zum Flashen benutzen.&lt;br&gt;
Man kann dies über ein eigenes ST-Link Adapter tun, der über USB an die 4 unteren Kontakte (GND, DCLK, DIO, 3.3) am Modul angeschlossen wird.
In diesem Fall benutzen wir aber eine USB zu UART Adapter mit 3,3 V. Ich verwende hierzu einen Adapter mit CP2102 Chip der gut unter Linux und Windows unterstützt wird.&lt;br&gt;
Auf einem Raspberry PI kann direkt der vorhandene UART benutzt werden. In diesem Fall benötigt man gar keine zusätzliche Hardware.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;STM32  Anschluss&lt;/th&gt;
&lt;th&gt;UART Adapter / RaspPi(BCM)&lt;/th&gt;
&lt;th&gt;Beschreibung (PC sicht)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;A9&lt;/td&gt;
&lt;td&gt;RXD (15)&lt;/td&gt;
&lt;td&gt;Receive&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;A10&lt;/td&gt;
&lt;td&gt;TXD (14)&lt;/td&gt;
&lt;td&gt;Transmit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;G&lt;/td&gt;
&lt;td&gt;GND&lt;/td&gt;
&lt;td&gt;Ground&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;3.3&lt;/td&gt;
&lt;td&gt;3V3&lt;/td&gt;
&lt;td&gt;Versorgung&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Achtung wenn das STM32-System über den UART Adapter versorgt wird (3.3 Volt) benötigt man keine weitere Versorgung!&lt;/p&gt;
&lt;p&gt;Nun muss man das Übertragungs- bzw Flash-Programm vom Hersteller bereitstellen. Es kann unter &lt;a href=&#34;https://sourceforge.net/projects/stm32flash/&#34;&gt;https://sourceforge.net/projects/stm32flash/&lt;/a&gt; heruntergeladen werden.
Danach muss es kompiliert und installiert werden.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 1&lt;/span&gt;cd ~
&lt;span class=&#34;ln&#34;&gt; 2&lt;/span&gt;mkdir stm
&lt;span class=&#34;ln&#34;&gt; 3&lt;/span&gt;cd stm
&lt;span class=&#34;ln&#34;&gt; 4&lt;/span&gt;apt get install build-essential
&lt;span class=&#34;ln&#34;&gt; 5&lt;/span&gt;wget --trust-server-name https://sourceforge.net/projects/stm32flash/files/stm32flash-0.5.tar.gz/download
&lt;span class=&#34;ln&#34;&gt; 6&lt;/span&gt;tar xzvf stm32flash-0.5.tar.gz
&lt;span class=&#34;ln&#34;&gt; 7&lt;/span&gt;cd stm32flash
&lt;span class=&#34;ln&#34;&gt; 8&lt;/span&gt;make
&lt;span class=&#34;ln&#34;&gt; 9&lt;/span&gt;sudo make install
&lt;span class=&#34;ln&#34;&gt;10&lt;/span&gt;cd ..
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Möchte man nun die STM32duino Firmware installieren, was nicht nötig ist, so muss man folgendermaßen vorgehen.&lt;/p&gt;
&lt;p&gt;Man holt sich eine zum STM32-System passende Firmware von &lt;a href=&#34;https://github.com/rogerclarkmelbourne/STM32duino-bootloader&#34;&gt;https://github.com/rogerclarkmelbourne/STM32duino-bootloader&lt;/a&gt; bzw. &lt;a href=&#34;https://github.com/rogerclarkmelbourne/STM32duino-bootloader/tree/master/binaries&#34;&gt;https://github.com/rogerclarkmelbourne/STM32duino-bootloader/tree/master/binaries&lt;/a&gt;. In meinen Fall ist &amp;quot;generic_boot20_pc13.bin&amp;quot; die richtige Version, da am Board eine LED an PC13 angeschlossen ist.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;wget https://github.com/rogerclarkmelbourne/STM32duino-bootloader/raw/master/binaries/generic_boot20_pc13.bin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Nun muss der obere gelbe Jumper (nahe an B11) von links (0) auf rechts (1) umgesetzt werden. Danach kann der USB Adapter angeschlossen werden. Üblicherweise wird er als &lt;code&gt;/dev/ttyUSB0&lt;/code&gt; in Linux eingebunden. Beim Raspberry Pi muss man den Parameter &lt;code&gt;/dev/ttyUSB0&lt;/code&gt; durch &lt;code&gt;/dev/ttyAMA0&lt;/code&gt; ersetzen. Zuvor muss man aber auch noch der Terminal-Dienst beenden werden. Dann kann die Firmware übertragen werden.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;USB UART-Adapter:&lt;/strong&gt;
&lt;code&gt;sudo stm32flash -g 0x8000000 -b 115200 -w generic_boot20_pc13.bin /dev/ttyUSB0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Raspberry Pi:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;sudo service serial-getty@ttyAMA0 stop
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;sudo stm32flash -g 0x8000000 -b 115200 -w generic_boot20_pc13.bin /dev/ttyAMA0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Folgende Ausgabe ist am Bildschirm zu sehen:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 1&lt;/span&gt;stm32flash 0.5
&lt;span class=&#34;ln&#34;&gt; 2&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 3&lt;/span&gt;http://stm32flash.sourceforge.net/
&lt;span class=&#34;ln&#34;&gt; 4&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 5&lt;/span&gt;Using Parser : Raw BINARY
&lt;span class=&#34;ln&#34;&gt; 6&lt;/span&gt;Interface serial_posix: 115200 8E1
&lt;span class=&#34;ln&#34;&gt; 7&lt;/span&gt;Version      : 0x22
&lt;span class=&#34;ln&#34;&gt; 8&lt;/span&gt;Option 1     : 0x00
&lt;span class=&#34;ln&#34;&gt; 9&lt;/span&gt;Option 2     : 0x00
&lt;span class=&#34;ln&#34;&gt;10&lt;/span&gt;Device ID    : 0x0410 (STM32F10xxx Medium-density)
&lt;span class=&#34;ln&#34;&gt;11&lt;/span&gt;- RAM        : 20KiB  (512b reserved by bootloader)
&lt;span class=&#34;ln&#34;&gt;12&lt;/span&gt;- Flash      : 128KiB (size first sector: 4x1024)
&lt;span class=&#34;ln&#34;&gt;13&lt;/span&gt;- Option RAM : 16b
&lt;span class=&#34;ln&#34;&gt;14&lt;/span&gt;- System RAM : 2KiB
&lt;span class=&#34;ln&#34;&gt;15&lt;/span&gt;Write to memory
&lt;span class=&#34;ln&#34;&gt;16&lt;/span&gt;Erasing memory
&lt;span class=&#34;ln&#34;&gt;17&lt;/span&gt;Wrote address 0x080056fc (100.00%) Done.
&lt;span class=&#34;ln&#34;&gt;18&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;19&lt;/span&gt;Starting execution at address 0x08000000... done.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Nun kann der USB-Adapter angesteckt und der Jumper zurück auf 0 gesetzt werden.&lt;br&gt;
Verbindet man den Mikrocontroller per USB mit dem PC System, werden folgenden Meldungen in Systemlog (Abrufbar mit &lt;code&gt;dmesg&lt;/code&gt;) geschrieben:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 1&lt;/span&gt;[ 1538.366444] usb 2-1: new full-speed USB device number 7 using xhci_hcd
&lt;span class=&#34;ln&#34;&gt; 2&lt;/span&gt;[ 1538.515763] usb 2-1: New USB device found, idVendor=1eaf, idProduct=0003, bcdDevice= 2.01
&lt;span class=&#34;ln&#34;&gt; 3&lt;/span&gt;[ 1538.515770] usb 2-1: New USB device strings: Mfr=1, Product=2, SerialNumber=3
&lt;span class=&#34;ln&#34;&gt; 4&lt;/span&gt;[ 1538.515774] usb 2-1: Product: Maple 003
&lt;span class=&#34;ln&#34;&gt; 5&lt;/span&gt;[ 1538.515777] usb 2-1: Manufacturer: LeafLabs
&lt;span class=&#34;ln&#34;&gt; 6&lt;/span&gt;[ 1538.515779] usb 2-1: SerialNumber: LLM 003
&lt;span class=&#34;ln&#34;&gt; 7&lt;/span&gt;[ 1539.898913] usb 2-1: USB disconnect, device number 7
&lt;span class=&#34;ln&#34;&gt; 8&lt;/span&gt;[ 1540.206402] usb 2-1: new full-speed USB device number 8 using xhci_hcd
&lt;span class=&#34;ln&#34;&gt; 9&lt;/span&gt;[ 1540.356171] usb 2-1: New USB device found, idVendor=1eaf, idProduct=0004, bcdDevice= 2.00
&lt;span class=&#34;ln&#34;&gt;10&lt;/span&gt;[ 1540.356177] usb 2-1: New USB device strings: Mfr=1, Product=2, SerialNumber=0
&lt;span class=&#34;ln&#34;&gt;11&lt;/span&gt;[ 1540.356180] usb 2-1: Product: Maple
&lt;span class=&#34;ln&#34;&gt;12&lt;/span&gt;[ 1540.356183] usb 2-1: Manufacturer: LeafLabs
&lt;span class=&#34;ln&#34;&gt;13&lt;/span&gt;[ 1540.377856] cdc_acm 2-1:1.0: ttyACM0: USB ACM device
&lt;span class=&#34;ln&#34;&gt;14&lt;/span&gt;[ 1540.378174] usbcore: registered new interface driver cdc_acm
&lt;span class=&#34;ln&#34;&gt;15&lt;/span&gt;[ 1540.378175] cdc_acm: USB Abstract Control Model driver for USB modems and ISDN adapters
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;arduino-ide-vorbereiten&#34;&gt;Arduino IDE vorbereiten&lt;/h2&gt;
&lt;h3 id=&#34;installation&#34;&gt;Installation&lt;/h3&gt;
&lt;p&gt;Bei Linux Mint 20 könnte man zwar die Arduino IDE mit &lt;code&gt;sudo apt install arduino&lt;/code&gt; installieren, dies ist aber eine zu alte Version. Darum sollte man sie manuell installieren. Auf der Web-Seite &lt;a href=&#34;https://www.arduino.cc/en/software&#34;&gt;https://www.arduino.cc/en/software&lt;/a&gt; kann die &amp;quot;Linux 64 bits&amp;quot; Version heruntergeladen werden.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;cd ~
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;tar xvf arduino-1.8.13-linux64.tar.xz
&lt;span class=&#34;ln&#34;&gt;3&lt;/span&gt;cd arduino-1.8.13/
&lt;span class=&#34;ln&#34;&gt;4&lt;/span&gt;sudo sh install.sh 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Mit dem Aufruf &lt;code&gt;sudo arduino&lt;/code&gt; oder dem Programmeintrag &amp;quot;Arduino IDE (Arduino)&amp;quot; wird das Programm dann gestartet.
Man muss nach dem ersten Start den aktuellen Benutzer der Gruppe &amp;quot;dialup&amp;quot; hinzufügen.&lt;/p&gt;
&lt;h3 id=&#34;stm32-support-und-einstellungen&#34;&gt;STM32 Support und Einstellungen&lt;/h3&gt;
&lt;p&gt;Nun muss man STM32 Support in der Arduino IDE hinzufügen. Dazu geht man im Menü auf
File -&amp;gt; Preferences bei Additional Board Manager URLs fügt man &amp;quot;http://dan.drown.org/stm32duino/package_STM32duino_index.json&amp;quot; hinzu.&lt;/p&gt;
&lt;p&gt;Danach geht man im Menü auf Tools -&amp;gt; Board -&amp;gt; Boards Manager. Dort kann man bei Suche &amp;quot;stm&amp;quot; eintragen und dann den Typ &amp;quot;STM32F1xx/GD32F1xx boards&amp;quot; installieren.&lt;br&gt;
Nun geht man im Menü auf Tools -&amp;gt; Board -&amp;gt; STM32F1 boards (Arduino_STM32) und wählt dort den Typ &amp;quot;Generic STM32F103C series&amp;quot; aus.&lt;br&gt;
Hat man eine Version mit 128 KB Flash so kann man Tools -&amp;gt; Variant einstellen.&lt;br&gt;
Bei Tools -&amp;gt; Upload method kann man nun &amp;quot;STM32duino bootloader&amp;quot; auswählen wenn die Firmware installiert ist. Ich bevorzuge aber unter Tools -&amp;gt; Variant die Einstellung &amp;quot;Serial&amp;quot;.&lt;br&gt;
Unter Tools -&amp;gt; Port muss auch die entsprechende Schnittstelle (/dev/ttyUSB0 oder /dev/ttyAMA0) ausgewählt werden. Man darf aber auch nicht vergessen vor dem Übertragen den Jumper auf 1 zu setzen. Verwendet man STM32duino so muss bei Port /dev/ttyACM0 ausgewählt werden.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/ArduinoIDE-STM32F103.png&#34; alt=&#34;ArduinoIDE STM32F103 Einstellungen&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;software-erstellen-und-übertragen&#34;&gt;Software erstellen und übertragen&lt;/h2&gt;
&lt;h2 id=&#34;sketch-laden&#34;&gt;Sketch laden&lt;/h2&gt;
&lt;p&gt;Nun lädt man sich das STM32-O-Scope Projekt herunter.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;git clone https://github.com/pingumacpenguin/STM32-O-Scope.git
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;cd STM32-O-Scope
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In der Arduino IDE kann das Projekt dann über das Menü mit File -&amp;gt; Open... und dem Auswählen der STM32-O-Scope.ino Datei, geladen werden.&lt;/p&gt;
&lt;h2 id=&#34;bibliotheken-installieren&#34;&gt;Bibliotheken installieren&lt;/h2&gt;
&lt;p&gt;Für das Projekt werden mehrere Librarys benötigt, die manuell installiert werden müssen.&lt;/p&gt;
&lt;p&gt;Im Menü auf Tools -&amp;gt; Manage Librarys... auswählen. Dort kann man bei Suche &amp;quot;gfx&amp;quot; eintragen und dann den Typ &amp;quot;Adafruit GFX Library&amp;quot; installieren.&lt;/p&gt;
&lt;p&gt;Von der Webseite &lt;a href=&#34;http://www.rinkydinkelectronics.com/library.php?id=92&#34;&gt;http://www.rinkydinkelectronics.com/library.php?id=92&lt;/a&gt; kann man sich die URTouch Library herunterladen.
Im Menü über Sketch -&amp;gt; include Library -&amp;gt; Add .ZIP library... kann die Zip-Datei URTouch.zip ausgewählt werden.&lt;/p&gt;
&lt;p&gt;Von der Webseite &lt;a href=&#34;https://github.com/PaulStoffregen/Time/archive/v1.6.zip&#34;&gt;https://github.com/PaulStoffregen/Time/archive/v1.6.zip&lt;/a&gt; kann man sich die Time Library herunterladen.
Im Menü über Sketch -&amp;gt; include Library -&amp;gt; Add .ZIP library... kann die Zip-Datei Time-1.6.zip ausgewählt werden.&lt;/p&gt;
&lt;p&gt;Von der Webseite &lt;a href=&#34;https://github.com/kroimon/Arduino-SerialCommand&#34;&gt;https://github.com/kroimon/Arduino-SerialCommand&lt;/a&gt; kann man sich die SerialCommand Library herunterladen. Da sie aber nicht also Zip-Datei angeboten wird, kann man sie lokal erstellen.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;git clone https://github.com/kroimon/Arduino-SerialCommand.git
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;mv Arduino-SerialCommand/ SerialCommand/
&lt;span class=&#34;ln&#34;&gt;3&lt;/span&gt;zip ~/Downloads/SerialCommand.zip SerialCommand/*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Im Menü über Sketch -&amp;gt; include Library -&amp;gt; Add .ZIP library... kann die Zip-Datei SerialCommand.zip ausgewählt werden.&lt;/p&gt;
&lt;h2 id=&#34;bibliotheken-korrigieren&#34;&gt;Bibliotheken korrigieren&lt;/h2&gt;
&lt;p&gt;Leider kann das Projekt nach der Installation der Librarys nicht erfolgreich kompiliert werden. Es bedarf mehrerer Anpassungen.&lt;/p&gt;
&lt;p&gt;Im Verzeichnis ~/.arduino15/packages/stm32duino/hardware/STM32F1/2020.12.26/libraries/Adafruit_ILI9341_STM muss in den Dateien
Adafruit_ILI9341_STM.cpp und Adafruit_ILI9341_STM.h alle Teile mit AS entfernt werden.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GFX_AS&lt;/code&gt; -&amp;gt; &lt;code&gt;GFX&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Im Verzeichnis ~/.arduino15/packages/stm32duino/hardware/STM32F1/2020.12.26/libraries/Wire/utility/ muss in den Dateien
WireBase.cpp und WireBase.h alle Pointer der write-Funktionen auf const Pointer umgestellt werden.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;size_t write(uint8*, int);&lt;/code&gt; -&amp;gt; &lt;code&gt;size_t write(const uint8*, int);&lt;/code&gt;&lt;br&gt;
&lt;code&gt;size_t write(int*, int);&lt;/code&gt; -&amp;gt; &lt;code&gt;size_t write(const int*, int);&lt;/code&gt;&lt;br&gt;
&lt;code&gt;void write(char*);&lt;/code&gt;  -&amp;gt; &lt;code&gt;void write(const char*);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;size_t WireBase::write(uint8* buf, int len) {&lt;/code&gt; -&amp;gt; &lt;code&gt;size_t WireBase::write(const uint8* buf, int len) {&lt;/code&gt;&lt;br&gt;
&lt;code&gt;size_t WireBase::write(int* buf, int len) {&lt;/code&gt; -&amp;gt; &lt;code&gt;size_t WireBase::write(const int* buf, int len) {&lt;/code&gt;&lt;br&gt;
&lt;code&gt;void WireBase::write(char* buf) {&lt;/code&gt; -&amp;gt; &lt;code&gt;void WireBase::write(const char* buf) {&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;übertragen&#34;&gt;Übertragen&lt;/h2&gt;
&lt;p&gt;Nun erst kann das Projekt mit der Hacken Schaltfläche verifiziert und danch mit der Pfeil Schaltfläche auf das System übertragnen werden.
Man darf nicht vergessen den Jumper vor dem Upload auf 1 zu setzen und danach wieder auf 0.&lt;/p&gt;
&lt;p&gt;Hat alle geklappt so wird am Display die aktuelle analoge Kurve vom Eingang B0 angezeigt.  Achtung nur von 0 bis 3,3 V verwenden!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/STM32-O-Scope.jpg&#34; alt=&#34;Anzeige 500 Hz Kondensator Lade- bzw. Endladekurve&#34;&gt;&lt;/p&gt;
        
      </description>
    </item>
    
  </channel>
</rss>
