<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mikrocontroller on Blog</title>
    <link>https://mstroh76.github.io/Blog/tags/mikrocontroller/</link>
    <description>Recent content in Mikrocontroller on Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2021, Martin Strohmayer</copyright>
    <lastBuildDate>Fri, 08 Dec 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://mstroh76.github.io/Blog/tags/mikrocontroller/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>WLED LED-Streifen mit ESP8266</title>
      <link>https://mstroh76.github.io/Blog/post/wled/</link>
      <pubDate>Fri, 08 Dec 2023 00:00:00 +0000</pubDate>
      
      <guid>https://mstroh76.github.io/Blog/post/wled/</guid>
      <description>
        
          &lt;p&gt;Einen über WLAN konfigurier und steuerbaren LED-Streifen ist denkbar einfach zu realisieren.&lt;/p&gt;
&lt;h2 id=&#34;beschreibung&#34;&gt;Beschreibung&lt;/h2&gt;
&lt;p&gt;Einen über WLAN konfigurier- und steuerbaren LED-Streifen ist denkbar einfach zu realisieren. Die Harware ist kostengünstig, die Verkabelung und Installation einfach, die Parametrierbarkeit enorm.
Man muss lediglich folgende Komponetnen haben&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LED Streifen mit WS2812 Chip (3-Polig), beliebig lang z. B. 30 LEDs&lt;/li&gt;
&lt;li&gt;ESP 8266 Board mit USB Anschluss (z.B. D1 Mini ESP8266)&lt;/li&gt;
&lt;li&gt;USB-Kabel und 5V Netzteil oder USB-Ausgang&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Man könnte es auch mit einem ESP-01 Board realisieren, aber dann muss man sich um die 5 V und 3,3 V Anschluss und Versorgung kümmern. Einfacher ist es gleich ein kostengünstiges D1 Mini Board zu verwenden. Es kann über einen Micro-USB-Anschluss programmiert und versorgt werden. Allerdings sollte man dann nicht zu viele LED ansteuern bzw. die Stromaufnahme mit der WLED Konfiguration  reduzieren (es wird empfohlen unter 1 A zu bleiben). Ansonsten müsste man ein eigenes Netzteil bzw. Versorgung für den LED-Streifen vorsehen.
Wir werden hier die einfacher Lösung, mit  der Versorgung über das ESP-Board verwenden und die LED-Leistung in WLED optimieren.&lt;/p&gt;
&lt;h2 id=&#34;anschluss&#34;&gt;Anschluss&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ESP&lt;/th&gt;
&lt;th&gt;LED-Stripe&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;5V&lt;/td&gt;
&lt;td&gt;+5V (Plus)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;- (Minus)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;D4&lt;/td&gt;
&lt;td&gt;Di (Data)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;D4 ist beim ESP GPIO2.&lt;/p&gt;
&lt;h2 id=&#34;installation-wled&#34;&gt;Installation WLED&lt;/h2&gt;
&lt;h3 id=&#34;usb-port-check&#34;&gt;USB Port Check&lt;/h3&gt;
&lt;p&gt;Bevor es nun zur Installation geht muss man überprüfen ob das ESP-Board am Linux System erkannt wird.&lt;/p&gt;
&lt;p&gt;ESP serielle Schnittstelle überprüfen:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;dmesg | tail -n 10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 1&lt;/span&gt;[ 1972.709131] usb 2-2: New USB device found, idVendor=1a86, idProduct=7523, bcdDevice= 2.54
&lt;span class=&#34;ln&#34;&gt; 2&lt;/span&gt;[ 1972.709146] usb 2-2: New USB device strings: Mfr=0, Product=2, SerialNumber=0
&lt;span class=&#34;ln&#34;&gt; 3&lt;/span&gt;[ 1972.709152] usb 2-2: Product: USB2.0-Ser!
&lt;span class=&#34;ln&#34;&gt; 4&lt;/span&gt;[ 1972.710859] ch341 2-2:1.0: ch341-uart converter detected
&lt;span class=&#34;ln&#34;&gt; 5&lt;/span&gt;[ 1972.711342] ch341-uart ttyUSB0: break control not supported, using simulated break
&lt;span class=&#34;ln&#34;&gt; 6&lt;/span&gt;[ 1972.711995] usb 2-2: ch341-uart converter now attached to ttyUSB0
&lt;span class=&#34;ln&#34;&gt; 7&lt;/span&gt;[ 1973.267032] input: BRLTTY 6.4 Linux Screen Driver Keyboard as /devices/virtual/input/input40
&lt;span class=&#34;ln&#34;&gt; 8&lt;/span&gt;[ 1973.385261] usb 2-2: usbfs: interface 0 claimed by ch341 while &amp;#39;brltty&amp;#39; sets config #1
&lt;span class=&#34;ln&#34;&gt; 9&lt;/span&gt;[ 1973.385623] ch341-uart ttyUSB0: ch341-uart converter now disconnected from ttyUSB0
&lt;span class=&#34;ln&#34;&gt;10&lt;/span&gt;[ 1973.385643] ch341 2-2:1.0: device disconnected
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Der USB-Port des ESP sollte also ttyUSB0 sein. Aber da gibt es einen Fehler mit BRLTTY.
BRLTTY ist &amp;quot;Braille Device Support&amp;quot; also ein Dienst für Blinde Menschen. Wir also zumeist nicht benötigt werden.
Wir deaktivieren den Dienst der die nutzung des ttyUSB0 Ports verhindert.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;sudo systemctl stop brltty
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;sudo systemctl disable brltty
&lt;span class=&#34;ln&#34;&gt;3&lt;/span&gt;sudo systemctl stop brltty-udev
&lt;span class=&#34;ln&#34;&gt;4&lt;/span&gt;sudo systemctl mask brltty-udev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Nun kann man nochmal ab und anstecken.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;dmesg | tail -n 10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;[ 3542.820230] usb 2-2: new full-speed USB device number 16 using xhci_hcd
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;[ 3542.969251] usb 2-2: New USB device found, idVendor=1a86, idProduct=7523, bcdDevice= 2.54
&lt;span class=&#34;ln&#34;&gt;3&lt;/span&gt;[ 3542.969266] usb 2-2: New USB device strings: Mfr=0, Product=2, SerialNumber=0
&lt;span class=&#34;ln&#34;&gt;4&lt;/span&gt;[ 3542.969272] usb 2-2: Product: USB2.0-Ser!
&lt;span class=&#34;ln&#34;&gt;5&lt;/span&gt;[ 3542.971132] ch341 2-2:1.0: ch341-uart converter detected
&lt;span class=&#34;ln&#34;&gt;6&lt;/span&gt;[ 3542.971613] ch341-uart ttyUSB0: break control not supported, using simulated break
&lt;span class=&#34;ln&#34;&gt;7&lt;/span&gt;[ 3542.971756] usb 2-2: ch341-uart converter now attached to ttyUSB0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;web-installation&#34;&gt;Web-Installation&lt;/h3&gt;
&lt;p&gt;Die Installaltion erfolggt super einfach mit Chromium Browser über Web-Seite &lt;a href=&#34;https://install.wled.me/&#34;&gt;https://install.wled.me/&lt;/a&gt;
Zuerst wählt man die aktuelle Version z. B. 0.14.0 und nach dem Drücken auf die Schaltfläche &amp;quot;Install&amp;quot; geht es los.
Zuerst muss man den richtige USB Port auswählen, also in userem Fall ttyUSB0.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/wled-install0.png&#34; alt=&#34;Web-Seite + USB Port&#34;&gt;&lt;/p&gt;
&lt;p&gt;Dann klick man sich durch die folgenden Fenster.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/wled-install1.png&#34; alt=&#34;Web-Seite + USB Port&#34;&gt;
&lt;img src=&#34;../../images/wled-install2.png&#34; alt=&#34;Device Dashboard&#34;&gt;
&lt;img src=&#34;../../images/wled-install3.png&#34; alt=&#34;Confirm installation&#34;&gt;
&lt;img src=&#34;../../images/wled-install4.png&#34; alt=&#34;Installing prepare&#34;&gt;
&lt;img src=&#34;../../images/wled-install5.png&#34; alt=&#34;Installing complete&#34;&gt;&lt;/p&gt;
&lt;p&gt;Dann kann man gleich das eigene WLAN Netzwerk parametrieren in das sich der ESP anmelden soll.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/wled-install6.png&#34; alt=&#34;Configure Wi-Fi&#34;&gt;
&lt;img src=&#34;../../images/wled-install7.png&#34; alt=&#34;Connected&#34;&gt;&lt;/p&gt;
&lt;p&gt;Nach dem Speichern muss man sich wieder in seinem Netzwerk anmelden und das Gerät (über Router oder Fing App) suchen bzw. die IP-Adresse herausfinden.&lt;/p&gt;
&lt;h3 id=&#34;manuelle-installation&#34;&gt;Manuelle Installation&lt;/h3&gt;
&lt;p&gt;Anschluss ESP-01 über USB-Adapter und  GPIO2 muss auf Ground gelegt werden (damit man den ESP programmieren kann).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;sudo apt-get install python3 python3-pip
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;sudo pip3 install esptool nodemcu-uploader
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;sptool.py -p /dev/ttyUSB0 chip_id
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 1&lt;/span&gt;esptool.py v4.6.2
&lt;span class=&#34;ln&#34;&gt; 2&lt;/span&gt;Serial port /dev/ttyUSB0
&lt;span class=&#34;ln&#34;&gt; 3&lt;/span&gt;Connecting...
&lt;span class=&#34;ln&#34;&gt; 4&lt;/span&gt;Detecting chip type... Unsupported detection protocol, switching and trying again...
&lt;span class=&#34;ln&#34;&gt; 5&lt;/span&gt;Connecting...
&lt;span class=&#34;ln&#34;&gt; 6&lt;/span&gt;Detecting chip type... ESP8266
&lt;span class=&#34;ln&#34;&gt; 7&lt;/span&gt;Chip is ESP8266EX
&lt;span class=&#34;ln&#34;&gt; 8&lt;/span&gt;Features: WiFi
&lt;span class=&#34;ln&#34;&gt; 9&lt;/span&gt;Crystal is 26MHz
&lt;span class=&#34;ln&#34;&gt;10&lt;/span&gt;MAC: 6c:df:7f:20:d4:a8
&lt;span class=&#34;ln&#34;&gt;11&lt;/span&gt;Stub is already running. No upload is necessary.
&lt;span class=&#34;ln&#34;&gt;12&lt;/span&gt;Chip ID: 0x0010d458
&lt;span class=&#34;ln&#34;&gt;13&lt;/span&gt;Hard resetting via RTS pin...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Download ESP-01 binary Datei von &lt;a href=&#34;https://github.com/Aircoookie/WLED/releases&#34;&gt;https://github.com/Aircoookie/WLED/releases&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;wget https://github.com/Aircoookie/WLED/releases/download/v0.14.0/WLED_0.14.0_ESP01.bin
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;esptool.py -p /dev/ttyUSB0 write_flash 0x0 ./WLED_0.14.0_ESP01.bin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 1&lt;/span&gt;esptool.py v4.6.2
&lt;span class=&#34;ln&#34;&gt; 2&lt;/span&gt;Serial port /dev/ttyUSB0
&lt;span class=&#34;ln&#34;&gt; 3&lt;/span&gt;Connecting...
&lt;span class=&#34;ln&#34;&gt; 4&lt;/span&gt;Detecting chip type... Unsupported detection protocol, switching and trying again...
&lt;span class=&#34;ln&#34;&gt; 5&lt;/span&gt;Connecting...
&lt;span class=&#34;ln&#34;&gt; 6&lt;/span&gt;Detecting chip type... ESP8266
&lt;span class=&#34;ln&#34;&gt; 7&lt;/span&gt;Chip is ESP8266EX
&lt;span class=&#34;ln&#34;&gt; 8&lt;/span&gt;Features: WiFi
&lt;span class=&#34;ln&#34;&gt; 9&lt;/span&gt;Crystal is 26MHz
&lt;span class=&#34;ln&#34;&gt;10&lt;/span&gt;MAC: 6c:df:7f:20:d4:a8
&lt;span class=&#34;ln&#34;&gt;11&lt;/span&gt;Stub is already running. No upload is necessary.
&lt;span class=&#34;ln&#34;&gt;12&lt;/span&gt;Configuring flash size...
&lt;span class=&#34;ln&#34;&gt;13&lt;/span&gt;Flash will be erased from 0x00000000 to 0x000d0fff...
&lt;span class=&#34;ln&#34;&gt;14&lt;/span&gt;Compressed 854000 bytes to 619031...
&lt;span class=&#34;ln&#34;&gt;15&lt;/span&gt;Wrote 854000 bytes (619031 compressed) at 0x00000000 in 54.8 seconds (effective 124.8 kbit/s)...
&lt;span class=&#34;ln&#34;&gt;16&lt;/span&gt;Hash of data verified.
&lt;span class=&#34;ln&#34;&gt;17&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;18&lt;/span&gt;Leaving...
&lt;span class=&#34;ln&#34;&gt;19&lt;/span&gt;Hard resetting via RTS pin...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;ESP-01 abstecken und entfernen der Ground Verbindung von GPIO2 sowie RXD und TXD.&lt;/p&gt;
&lt;p&gt;Nun kann man den WLAN AccessPoint WLED-AP finden. Bei der Verbindung muss man das Password &lt;strong&gt;wled1234&lt;/strong&gt; eingeben.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/wled-ap-wled.png&#34; alt=&#34;WLED AP&#34;&gt;&lt;/p&gt;
&lt;p&gt;Das Web-Interface ist nun unter http://4.3.2.1/ errreichbar.
Nun kann man sein eigenes WLAN-Netzwerk einrichten damit sich der ESP damit verbinden kann.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/wled-ap-configuration.png&#34; alt=&#34;WiFi configuration&#34;&gt;&lt;/p&gt;
&lt;p&gt;Nach dem Speichern muss man sich wieder in seinem Netzwerk anmelden und das Gerät (über Router oder Fing App) suchen bzw. die IP-Adresse herausfinden.&lt;/p&gt;
&lt;h2 id=&#34;wled-konfiguration&#34;&gt;WLED Konfiguration&lt;/h2&gt;
&lt;p&gt;Auf der ersten Seite kann man sich verschiedene Presets anlegen (ID und Name) und die gewünschten Effekte, Farben und Muster auswählen.
Man kann sich hier auch einen &amp;quot;Ausgeschaltet&amp;quot; Preset anlegen, ich verwende dazu ID 99.
Unter der Schatfläche Config können wir verschiedene Einstellungen vornehmen.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/wled-presets.png&#34; alt=&#34;Presets&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;uhrzeit-und-zeitsteuerung&#34;&gt;Uhrzeit und Zeitsteuerung&lt;/h3&gt;
&lt;p&gt;Unter &amp;quot;Config&amp;quot;/&amp;quot;Time &amp;amp; Macros&amp;quot; können wir einen neuen NTP-Server eingeben, z. B. 0.at.pool.ntp.org.
Wichtiger ist allerdings die Zeitzone für Zentral-Europa also CET/CEST zu setzen, dann sollte die angezeigte Zeit bereits stimmen.&lt;br&gt;
Weiter unten kann man dann auch zeitgesteuert den Streifen ein- und ausschalten bzw auch verschiedene Presets laden.&lt;/p&gt;
&lt;h3 id=&#34;led-strom-begrenzen&#34;&gt;LED Strom begrenzen&lt;/h3&gt;
&lt;p&gt;Da wir keine Leistungfähiges gesondertes Netzteil einsetzen sollte man den Strom der LEDs begrenzen.
Das kann ünter &amp;quot;Config&amp;quot;/&amp;quot;LED Preferences&amp;quot; gemacht werden.&lt;/p&gt;
&lt;p&gt;Enable automatic brightness limiter: Ja&lt;br&gt;
Maximum Current: 650 mA&lt;br&gt;
LED voltage (Max. current for a single LED): 5V (efficient (35mA)&lt;/p&gt;
&lt;p&gt;Mit der Schaltfläche Save ganz oben oder ganz unten kann man die Einstellungen sichern.&lt;/p&gt;
&lt;h3 id=&#34;backup&#34;&gt;Backup&lt;/h3&gt;
&lt;p&gt;Hat man alles eingerichtet kann man sich die Presets und Konfigurationen unter  &amp;quot;Config&amp;quot;/&amp;quot;Security &amp;amp; Update&amp;quot; mit der Schaltfläche &amp;quot;Backup presets&amp;quot; und &amp;quot;Backup configuration&amp;quot; lokal speichern. Mit den entsprechenden &amp;quot;Upload&amp;quot; Schlatflächen können sie wieder eingespielt werden.&lt;/p&gt;
        
      </description>
    </item>
    
    <item>
      <title>STM32-O-Scope das &lt;10 Euro Osilloskop</title>
      <link>https://mstroh76.github.io/Blog/post/stm32-o-scope/</link>
      <pubDate>Sun, 31 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://mstroh76.github.io/Blog/post/stm32-o-scope/</guid>
      <description>
        
          &lt;p&gt;Mit einem günstigen STM32 Mikrocontroller und einen SPI-TFT-Display kann man einfaches Oszilloskop bauen. Hier erfährst du wie das geht...&lt;/p&gt;
&lt;h2 id=&#34;beschreibung&#34;&gt;Beschreibung&lt;/h2&gt;
&lt;p&gt;Das Projekt &lt;a href=&#34;https://github.com/pingumacpenguin/STM32-O-Scope&#34;&gt;STM32-O-Scope&lt;/a&gt; von pingumacpenguin macht aus einem günstigen STM32 Mikrocontroller System und einem SPI-TFT-Display ein einfaches Oszilloskop. Das Projekt ist extrem einfach aufgebaut. Leider wird die Firmware aber nur als Source bzw. Arduino IDE Projekt angeboten. Man muss sich also um die Konfiguration der Entwicklungsumgebung, um die Bibliotheken und die Kompilierung und schlussendlich den Flashvorgang selbst kümmern. Hier warten leider viele Hürden, also doch kein Projekt für Anfänger.
Die dazugehörige README und &lt;a href=&#34;https://github.com/pingumacpenguin/STM32-O-Scope/wiki&#34;&gt;Wiki-Seite&lt;/a&gt; helfen nämlich an den entscheidenden Stellen nicht weiter!
Eine weiter neuere Anleitung aus 2017 von satoshinm blog &lt;a href=&#34;https://satoshinm.github.io/blog/180105_stm32scope_building_an_amazing_10_oscilloscope_with_an_stm32_blue_pill_lcd_touchscreen_and_stm32-o-scope_software.html&#34;&gt;Building an Amazing $10 Oscilloscope with an STM32 blue pill, LCD touchscreen, and STM32-O-Scope software&lt;/a&gt; verbessert die Situation.
Hier ist die Pin-Belegung übersichtlich beschrieben. Aber das Kapitel &amp;quot;Compiling the software&amp;quot; enthält einige Anpassungen aber auch irrefürende Hinweise und führt Schlussendlich auch nicht zur fehlerfreien Kompilierung.&lt;/p&gt;
&lt;p&gt;Aus diesem Grund habe ich mich dazu entschlossen eine möglichst einfache detaillierte Schritt für Schritt Anleitung zu erstellen.&lt;/p&gt;
&lt;h2 id=&#34;komponenten&#34;&gt;Komponenten&lt;/h2&gt;
&lt;p&gt;Man benötigt für das Projekt lediglich:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;STM32F103C8T6 ARM STM32 Minimum System Development Board Module , China Preis ca. 2 Euro&lt;/li&gt;
&lt;li&gt;TFT Display mit ili9341 Chipsatz, 320x240 Auflösung (verfügbar mit 2.2, 2.4 oder 2.8 Zoll Größe ), China Preis 5-8 Euro&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://www.st.com/en/microcontrollers-microprocessors/stm32f103.html&#34;&gt;STM32F103&lt;/a&gt; ist eine Mikrocontroller von STMicrosystems mit einem ARM Cortex-M3 Prozessorkern. Die Taktrate beträgt maximal 72 MHz. Der Code &amp;quot;C8&amp;quot; im Namen bedeutet, dass 64 kByte Flash Speicher (undokumentiert oft auch 128 kByte verfügbar) und 20 kByte SRAM im IC vorhanden sind.
Die Systemplatine mit diesem IC wird für teilweise unter 2 Euro verkauft. Es wird auch mit dem Namen &amp;quot;blue pill&amp;quot; bezeichnet.  Mehr Informationen über das System findet man auf &lt;a href=&#34;http://stefanfrings.de/stm32/stm32f1.html#bluepill&#34;&gt;http://stefanfrings.de/stm32/stm32f1.html#bluepill&lt;/a&gt; . Aber Achtung, teilweise werden Nachbauten mit einem Clone IC verkauft. Dieser Chip fängt dann mit einer anderen Bezeichnung, wie &amp;quot;CH32&amp;quot; oder &amp;quot;CS32&amp;quot; an. &lt;strong&gt;Hände weg von diesen Clone Systemen!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Das Display mit dem ili9341 ist ein weit verbreiteter standard Typ mit SPI-Schnittstelle. Optional wird auch die Touch Funktion des Displays unterstützt. In dieser Anleitung wird sie aber nicht beachtet.&lt;/p&gt;
&lt;h2 id=&#34;anschluss&#34;&gt;Anschluss&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;STM32  Anschluss&lt;/th&gt;
&lt;th&gt;LCD Anschluss&lt;/th&gt;
&lt;th&gt;Beschreibung&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;A0&lt;/td&gt;
&lt;td&gt;D/C&lt;/td&gt;
&lt;td&gt;Data/Command&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;A1&lt;/td&gt;
&lt;td&gt;CS&lt;/td&gt;
&lt;td&gt;Chip select&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;A2&lt;/td&gt;
&lt;td&gt;RESET&lt;/td&gt;
&lt;td&gt;Reset&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;3.3&lt;/td&gt;
&lt;td&gt;LED&lt;/td&gt;
&lt;td&gt;Hintergrundbeleuchtung&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;A5&lt;/td&gt;
&lt;td&gt;SCK&lt;/td&gt;
&lt;td&gt;SPI Takt&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;A6&lt;/td&gt;
&lt;td&gt;SDO(MISO)&lt;/td&gt;
&lt;td&gt;SPI master input / slave output nur bei Touchfunktion&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;A7&lt;/td&gt;
&lt;td&gt;SDI(MOSI)&lt;/td&gt;
&lt;td&gt;SPI master output / slave input&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;G&lt;/td&gt;
&lt;td&gt;GND&lt;/td&gt;
&lt;td&gt;Ground&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;3.3&lt;/td&gt;
&lt;td&gt;VCC&lt;/td&gt;
&lt;td&gt;Versorgung&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Optional könnte man die Hintergrundbeleuchtung auch bei A3 Anschließen, allerdings ist die Stromaufnahme zumeist zu hoch für den Chip Ausgang (in meinen Fall 26 mA). Daher würde ich ihn fix auf 3,3 V legen. Ansonsten sollte man eine FET- oder Transistorschaltung vorsehen, sofern diese nicht im Display vorhanden ist.&lt;/p&gt;
&lt;p&gt;Der Anschluss B0 ist der Analoge Eingang des Oszilloskopes. Achtung der Eingang ist unbeschaltet nur für Spannungen von 0 bis 3,3 V geeignet!&lt;br&gt;
Am Ausgang B1 wird ein 500 Hz Rechtecksignal ausgegeben, das zu Verifikation verwendet werden kann. Eine Drahtbrücke von B0 zu B1 führt also zu Messen dieses Rechtecksignals. Dies sollte für den ersten Test durchgeführt werden.&lt;/p&gt;
&lt;h2 id=&#34;stm32duino-firmware-übertragen&#34;&gt;STM32duino Firmware übertragen&lt;/h2&gt;
&lt;p&gt;Bei den üblichen Anleitungen wird empfohlen STM32duino auf das System aufzuspielen. Das hat den Vorteil, dass ab dann das System direkt über den USB-Anschluss programmiert werden kann. Auf den ersten Blick eine Vorteil, allerdings benötigt die Firmware einen großen Teil vom Speicher und verringert also den nutzbaren Flash-Speicher unseres Programms.&lt;br&gt;
Bei mir hat das dann nicht funktioniert, ich vermute wegen zu wenig Speicher.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Das aufspielen der STM32duino Firmware ist also nicht nötig!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Auch wenn man die Firmware aufspielen möchte, so muss man zumindest bei ersten mal eine andere Möglichkeit zum Flashen benutzen.&lt;br&gt;
Man kann dies über ein eigenes ST-Link Adapter tun, der über USB an die 4 unteren Kontakte (GND, DCLK, DIO, 3.3) am Modul angeschlossen wird.
In diesem Fall benutzen wir aber eine USB zu UART Adapter mit 3,3 V. Ich verwende hierzu einen Adapter mit CP2102 Chip der gut unter Linux und Windows unterstützt wird.&lt;br&gt;
Auf einem Raspberry PI kann direkt der vorhandene UART benutzt werden. In diesem Fall benötigt man gar keine zusätzliche Hardware.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;STM32  Anschluss&lt;/th&gt;
&lt;th&gt;UART Adapter / RaspPi(BCM)&lt;/th&gt;
&lt;th&gt;Beschreibung (PC sicht)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;A9&lt;/td&gt;
&lt;td&gt;RXD (15)&lt;/td&gt;
&lt;td&gt;Receive&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;A10&lt;/td&gt;
&lt;td&gt;TXD (14)&lt;/td&gt;
&lt;td&gt;Transmit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;G&lt;/td&gt;
&lt;td&gt;GND&lt;/td&gt;
&lt;td&gt;Ground&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;3.3&lt;/td&gt;
&lt;td&gt;3V3&lt;/td&gt;
&lt;td&gt;Versorgung&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Achtung wenn das STM32-System über den UART Adapter versorgt wird (3.3 Volt) benötigt man keine weitere Versorgung!&lt;/p&gt;
&lt;p&gt;Nun muss man das Übertragungs- bzw Flash-Programm vom Hersteller bereitstellen. Es kann unter &lt;a href=&#34;https://sourceforge.net/projects/stm32flash/&#34;&gt;https://sourceforge.net/projects/stm32flash/&lt;/a&gt; heruntergeladen werden.
Danach muss es kompiliert und installiert werden.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 1&lt;/span&gt;cd ~
&lt;span class=&#34;ln&#34;&gt; 2&lt;/span&gt;mkdir stm
&lt;span class=&#34;ln&#34;&gt; 3&lt;/span&gt;cd stm
&lt;span class=&#34;ln&#34;&gt; 4&lt;/span&gt;apt get install build-essential
&lt;span class=&#34;ln&#34;&gt; 5&lt;/span&gt;wget --trust-server-name https://sourceforge.net/projects/stm32flash/files/stm32flash-0.5.tar.gz/download
&lt;span class=&#34;ln&#34;&gt; 6&lt;/span&gt;tar xzvf stm32flash-0.5.tar.gz
&lt;span class=&#34;ln&#34;&gt; 7&lt;/span&gt;cd stm32flash
&lt;span class=&#34;ln&#34;&gt; 8&lt;/span&gt;make
&lt;span class=&#34;ln&#34;&gt; 9&lt;/span&gt;sudo make install
&lt;span class=&#34;ln&#34;&gt;10&lt;/span&gt;cd ..
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Möchte man nun die STM32duino Firmware installieren, was nicht nötig ist, so muss man folgendermaßen vorgehen.&lt;/p&gt;
&lt;p&gt;Man holt sich eine zum STM32-System passende Firmware von &lt;a href=&#34;https://github.com/rogerclarkmelbourne/STM32duino-bootloader&#34;&gt;https://github.com/rogerclarkmelbourne/STM32duino-bootloader&lt;/a&gt; bzw. &lt;a href=&#34;https://github.com/rogerclarkmelbourne/STM32duino-bootloader/tree/master/binaries&#34;&gt;https://github.com/rogerclarkmelbourne/STM32duino-bootloader/tree/master/binaries&lt;/a&gt;. In meinen Fall ist &amp;quot;generic_boot20_pc13.bin&amp;quot; die richtige Version, da am Board eine LED an PC13 angeschlossen ist.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;wget https://github.com/rogerclarkmelbourne/STM32duino-bootloader/raw/master/binaries/generic_boot20_pc13.bin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Nun muss der obere gelbe Jumper (nahe an B11) von links (0) auf rechts (1) umgesetzt werden. Danach kann der USB Adapter angeschlossen werden. Üblicherweise wird er als &lt;code&gt;/dev/ttyUSB0&lt;/code&gt; in Linux eingebunden. Beim Raspberry Pi muss man den Parameter &lt;code&gt;/dev/ttyUSB0&lt;/code&gt; durch &lt;code&gt;/dev/ttyAMA0&lt;/code&gt; ersetzen. Zuvor muss man aber auch noch der Terminal-Dienst beenden werden. Dann kann die Firmware übertragen werden.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;USB UART-Adapter:&lt;/strong&gt;
&lt;code&gt;sudo stm32flash -g 0x8000000 -b 115200 -w generic_boot20_pc13.bin /dev/ttyUSB0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Raspberry Pi:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;sudo service serial-getty@ttyAMA0 stop
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;sudo stm32flash -g 0x8000000 -b 115200 -w generic_boot20_pc13.bin /dev/ttyAMA0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Folgende Ausgabe ist am Bildschirm zu sehen:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 1&lt;/span&gt;stm32flash 0.5
&lt;span class=&#34;ln&#34;&gt; 2&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 3&lt;/span&gt;http://stm32flash.sourceforge.net/
&lt;span class=&#34;ln&#34;&gt; 4&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 5&lt;/span&gt;Using Parser : Raw BINARY
&lt;span class=&#34;ln&#34;&gt; 6&lt;/span&gt;Interface serial_posix: 115200 8E1
&lt;span class=&#34;ln&#34;&gt; 7&lt;/span&gt;Version      : 0x22
&lt;span class=&#34;ln&#34;&gt; 8&lt;/span&gt;Option 1     : 0x00
&lt;span class=&#34;ln&#34;&gt; 9&lt;/span&gt;Option 2     : 0x00
&lt;span class=&#34;ln&#34;&gt;10&lt;/span&gt;Device ID    : 0x0410 (STM32F10xxx Medium-density)
&lt;span class=&#34;ln&#34;&gt;11&lt;/span&gt;- RAM        : 20KiB  (512b reserved by bootloader)
&lt;span class=&#34;ln&#34;&gt;12&lt;/span&gt;- Flash      : 128KiB (size first sector: 4x1024)
&lt;span class=&#34;ln&#34;&gt;13&lt;/span&gt;- Option RAM : 16b
&lt;span class=&#34;ln&#34;&gt;14&lt;/span&gt;- System RAM : 2KiB
&lt;span class=&#34;ln&#34;&gt;15&lt;/span&gt;Write to memory
&lt;span class=&#34;ln&#34;&gt;16&lt;/span&gt;Erasing memory
&lt;span class=&#34;ln&#34;&gt;17&lt;/span&gt;Wrote address 0x080056fc (100.00%) Done.
&lt;span class=&#34;ln&#34;&gt;18&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;19&lt;/span&gt;Starting execution at address 0x08000000... done.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Nun kann der USB-Adapter angesteckt und der Jumper zurück auf 0 gesetzt werden.&lt;br&gt;
Verbindet man den Mikrocontroller per USB mit dem PC System, werden folgenden Meldungen in Systemlog (Abrufbar mit &lt;code&gt;dmesg&lt;/code&gt;) geschrieben:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 1&lt;/span&gt;[ 1538.366444] usb 2-1: new full-speed USB device number 7 using xhci_hcd
&lt;span class=&#34;ln&#34;&gt; 2&lt;/span&gt;[ 1538.515763] usb 2-1: New USB device found, idVendor=1eaf, idProduct=0003, bcdDevice= 2.01
&lt;span class=&#34;ln&#34;&gt; 3&lt;/span&gt;[ 1538.515770] usb 2-1: New USB device strings: Mfr=1, Product=2, SerialNumber=3
&lt;span class=&#34;ln&#34;&gt; 4&lt;/span&gt;[ 1538.515774] usb 2-1: Product: Maple 003
&lt;span class=&#34;ln&#34;&gt; 5&lt;/span&gt;[ 1538.515777] usb 2-1: Manufacturer: LeafLabs
&lt;span class=&#34;ln&#34;&gt; 6&lt;/span&gt;[ 1538.515779] usb 2-1: SerialNumber: LLM 003
&lt;span class=&#34;ln&#34;&gt; 7&lt;/span&gt;[ 1539.898913] usb 2-1: USB disconnect, device number 7
&lt;span class=&#34;ln&#34;&gt; 8&lt;/span&gt;[ 1540.206402] usb 2-1: new full-speed USB device number 8 using xhci_hcd
&lt;span class=&#34;ln&#34;&gt; 9&lt;/span&gt;[ 1540.356171] usb 2-1: New USB device found, idVendor=1eaf, idProduct=0004, bcdDevice= 2.00
&lt;span class=&#34;ln&#34;&gt;10&lt;/span&gt;[ 1540.356177] usb 2-1: New USB device strings: Mfr=1, Product=2, SerialNumber=0
&lt;span class=&#34;ln&#34;&gt;11&lt;/span&gt;[ 1540.356180] usb 2-1: Product: Maple
&lt;span class=&#34;ln&#34;&gt;12&lt;/span&gt;[ 1540.356183] usb 2-1: Manufacturer: LeafLabs
&lt;span class=&#34;ln&#34;&gt;13&lt;/span&gt;[ 1540.377856] cdc_acm 2-1:1.0: ttyACM0: USB ACM device
&lt;span class=&#34;ln&#34;&gt;14&lt;/span&gt;[ 1540.378174] usbcore: registered new interface driver cdc_acm
&lt;span class=&#34;ln&#34;&gt;15&lt;/span&gt;[ 1540.378175] cdc_acm: USB Abstract Control Model driver for USB modems and ISDN adapters
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;arduino-ide-vorbereiten&#34;&gt;Arduino IDE vorbereiten&lt;/h2&gt;
&lt;h3 id=&#34;installation&#34;&gt;Installation&lt;/h3&gt;
&lt;p&gt;Bei Linux Mint 20 könnte man zwar die Arduino IDE mit &lt;code&gt;sudo apt install arduino&lt;/code&gt; installieren, dies ist aber eine zu alte Version. Darum sollte man sie manuell installieren. Auf der Web-Seite &lt;a href=&#34;https://www.arduino.cc/en/software&#34;&gt;https://www.arduino.cc/en/software&lt;/a&gt; kann die &amp;quot;Linux 64 bits&amp;quot; Version heruntergeladen werden.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;cd ~
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;tar xvf arduino-1.8.13-linux64.tar.xz
&lt;span class=&#34;ln&#34;&gt;3&lt;/span&gt;cd arduino-1.8.13/
&lt;span class=&#34;ln&#34;&gt;4&lt;/span&gt;sudo sh install.sh 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Mit dem Aufruf &lt;code&gt;sudo arduino&lt;/code&gt; oder dem Programmeintrag &amp;quot;Arduino IDE (Arduino)&amp;quot; wird das Programm dann gestartet.
Man muss nach dem ersten Start den aktuellen Benutzer der Gruppe &amp;quot;dialup&amp;quot; hinzufügen.&lt;/p&gt;
&lt;h3 id=&#34;stm32-support-und-einstellungen&#34;&gt;STM32 Support und Einstellungen&lt;/h3&gt;
&lt;p&gt;Nun muss man STM32 Support in der Arduino IDE hinzufügen. Dazu geht man im Menü auf
File -&amp;gt; Preferences bei Additional Board Manager URLs fügt man &amp;quot;http://dan.drown.org/stm32duino/package_STM32duino_index.json&amp;quot; hinzu.&lt;/p&gt;
&lt;p&gt;Danach geht man im Menü auf Tools -&amp;gt; Board -&amp;gt; Boards Manager. Dort kann man bei Suche &amp;quot;stm&amp;quot; eintragen und dann den Typ &amp;quot;STM32F1xx/GD32F1xx boards&amp;quot; installieren.&lt;br&gt;
Nun geht man im Menü auf Tools -&amp;gt; Board -&amp;gt; STM32F1 boards (Arduino_STM32) und wählt dort den Typ &amp;quot;Generic STM32F103C series&amp;quot; aus.&lt;br&gt;
Hat man eine Version mit 128 KB Flash so kann man Tools -&amp;gt; Variant einstellen.&lt;br&gt;
Bei Tools -&amp;gt; Upload method kann man nun &amp;quot;STM32duino bootloader&amp;quot; auswählen wenn die Firmware installiert ist. Ich bevorzuge aber unter Tools -&amp;gt; Variant die Einstellung &amp;quot;Serial&amp;quot;.&lt;br&gt;
Unter Tools -&amp;gt; Port muss auch die entsprechende Schnittstelle (/dev/ttyUSB0 oder /dev/ttyAMA0) ausgewählt werden. Man darf aber auch nicht vergessen vor dem Übertragen den Jumper auf 1 zu setzen. Verwendet man STM32duino so muss bei Port /dev/ttyACM0 ausgewählt werden.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/ArduinoIDE-STM32F103.png&#34; alt=&#34;ArduinoIDE STM32F103 Einstellungen&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;software-erstellen-und-übertragen&#34;&gt;Software erstellen und übertragen&lt;/h2&gt;
&lt;h2 id=&#34;sketch-laden&#34;&gt;Sketch laden&lt;/h2&gt;
&lt;p&gt;Nun lädt man sich das STM32-O-Scope Projekt herunter.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;git clone https://github.com/pingumacpenguin/STM32-O-Scope.git
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;cd STM32-O-Scope
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In der Arduino IDE kann das Projekt dann über das Menü mit File -&amp;gt; Open... und dem Auswählen der STM32-O-Scope.ino Datei, geladen werden.&lt;/p&gt;
&lt;h2 id=&#34;bibliotheken-installieren&#34;&gt;Bibliotheken installieren&lt;/h2&gt;
&lt;p&gt;Für das Projekt werden mehrere Librarys benötigt, die manuell installiert werden müssen.&lt;/p&gt;
&lt;p&gt;Im Menü auf Tools -&amp;gt; Manage Librarys... auswählen. Dort kann man bei Suche &amp;quot;gfx&amp;quot; eintragen und dann den Typ &amp;quot;Adafruit GFX Library&amp;quot; installieren.&lt;/p&gt;
&lt;p&gt;Von der Webseite &lt;a href=&#34;http://www.rinkydinkelectronics.com/library.php?id=92&#34;&gt;http://www.rinkydinkelectronics.com/library.php?id=92&lt;/a&gt; kann man sich die URTouch Library herunterladen.
Im Menü über Sketch -&amp;gt; include Library -&amp;gt; Add .ZIP library... kann die Zip-Datei URTouch.zip ausgewählt werden.&lt;/p&gt;
&lt;p&gt;Von der Webseite &lt;a href=&#34;https://github.com/PaulStoffregen/Time/archive/v1.6.zip&#34;&gt;https://github.com/PaulStoffregen/Time/archive/v1.6.zip&lt;/a&gt; kann man sich die Time Library herunterladen.
Im Menü über Sketch -&amp;gt; include Library -&amp;gt; Add .ZIP library... kann die Zip-Datei Time-1.6.zip ausgewählt werden.&lt;/p&gt;
&lt;p&gt;Von der Webseite &lt;a href=&#34;https://github.com/kroimon/Arduino-SerialCommand&#34;&gt;https://github.com/kroimon/Arduino-SerialCommand&lt;/a&gt; kann man sich die SerialCommand Library herunterladen. Da sie aber nicht also Zip-Datei angeboten wird, kann man sie lokal erstellen.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;git clone https://github.com/kroimon/Arduino-SerialCommand.git
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;mv Arduino-SerialCommand/ SerialCommand/
&lt;span class=&#34;ln&#34;&gt;3&lt;/span&gt;zip ~/Downloads/SerialCommand.zip SerialCommand/*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Im Menü über Sketch -&amp;gt; include Library -&amp;gt; Add .ZIP library... kann die Zip-Datei SerialCommand.zip ausgewählt werden.&lt;/p&gt;
&lt;h2 id=&#34;bibliotheken-korrigieren&#34;&gt;Bibliotheken korrigieren&lt;/h2&gt;
&lt;p&gt;Leider kann das Projekt nach der Installation der Librarys nicht erfolgreich kompiliert werden. Es bedarf mehrerer Anpassungen.&lt;/p&gt;
&lt;p&gt;Im Verzeichnis ~/.arduino15/packages/stm32duino/hardware/STM32F1/2020.12.26/libraries/Adafruit_ILI9341_STM muss in den Dateien
Adafruit_ILI9341_STM.cpp und Adafruit_ILI9341_STM.h alle Teile mit AS entfernt werden.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GFX_AS&lt;/code&gt; -&amp;gt; &lt;code&gt;GFX&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Im Verzeichnis ~/.arduino15/packages/stm32duino/hardware/STM32F1/2020.12.26/libraries/Wire/utility/ muss in den Dateien
WireBase.cpp und WireBase.h alle Pointer der write-Funktionen auf const Pointer umgestellt werden.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;size_t write(uint8*, int);&lt;/code&gt; -&amp;gt; &lt;code&gt;size_t write(const uint8*, int);&lt;/code&gt;&lt;br&gt;
&lt;code&gt;size_t write(int*, int);&lt;/code&gt; -&amp;gt; &lt;code&gt;size_t write(const int*, int);&lt;/code&gt;&lt;br&gt;
&lt;code&gt;void write(char*);&lt;/code&gt;  -&amp;gt; &lt;code&gt;void write(const char*);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;size_t WireBase::write(uint8* buf, int len) {&lt;/code&gt; -&amp;gt; &lt;code&gt;size_t WireBase::write(const uint8* buf, int len) {&lt;/code&gt;&lt;br&gt;
&lt;code&gt;size_t WireBase::write(int* buf, int len) {&lt;/code&gt; -&amp;gt; &lt;code&gt;size_t WireBase::write(const int* buf, int len) {&lt;/code&gt;&lt;br&gt;
&lt;code&gt;void WireBase::write(char* buf) {&lt;/code&gt; -&amp;gt; &lt;code&gt;void WireBase::write(const char* buf) {&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;übertragen&#34;&gt;Übertragen&lt;/h2&gt;
&lt;p&gt;Nun erst kann das Projekt mit der Hacken Schaltfläche verifiziert und danch mit der Pfeil Schaltfläche auf das System übertragnen werden.
Man darf nicht vergessen den Jumper vor dem Upload auf 1 zu setzen und danach wieder auf 0.&lt;/p&gt;
&lt;p&gt;Hat alle geklappt so wird am Display die aktuelle analoge Kurve vom Eingang B0 angezeigt.  Achtung nur von 0 bis 3,3 V verwenden!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/STM32-O-Scope.jpg&#34; alt=&#34;Anzeige 500 Hz Kondensator Lade- bzw. Endladekurve&#34;&gt;&lt;/p&gt;
        
      </description>
    </item>
    
  </channel>
</rss>
